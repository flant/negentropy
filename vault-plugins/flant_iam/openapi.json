{
  "openapi": "3.0.2",
  "info": {
    "title": "HashiCorp Vault API",
    "description": "HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.",
    "version": "1.7.1",
    "license": {
      "name": "Mozilla Public License 2.0",
      "url": "https://www.mozilla.org/en-US/MPL/2.0"
    }
  },
  "paths": {
    "/auth/approle/login": {
      "description": "Issue a token based on the credentials supplied",
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Issue a token based on the credentials supplied",
        "operationId": "postAuthApproleLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "role_id": {
                    "type": "string",
                    "description": "Unique identifier of the Role. Required to be supplied when the 'bind_secret_id' constraint is set."
                  },
                  "secret_id": {
                    "type": "string",
                    "description": "SecretID belong to the App role",
                    "default": ""
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/approle/role": {
      "description": "Lists all the roles registered with the backend.",
      "get": {
        "summary": "Lists all the roles registered with the backend.",
        "operationId": "getAuthApproleRole",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}": {
      "description": "Register an role with the backend.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Register an role with the backend.",
        "operationId": "getAuthApproleRoleRole_name",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register an role with the backend.",
        "operationId": "postAuthApproleRoleRole_name",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "bind_secret_id": {
                    "type": "boolean",
                    "description": "Impose secret_id to be presented when logging in using this role. Defaults to 'true'.",
                    "default": true
                  },
                  "bound_cidr_list": {
                    "type": "array",
                    "description": "Use \"secret_id_bound_cidrs\" instead.",
                    "items": {
                      "type": "string"
                    },
                    "deprecated": true
                  },
                  "local_secret_ids": {
                    "type": "boolean",
                    "description": "If set, the secret IDs generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later."
                  },
                  "period": {
                    "type": "integer",
                    "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
                    "format": "seconds",
                    "deprecated": true
                  },
                  "policies": {
                    "type": "array",
                    "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
                    "items": {
                      "type": "string"
                    },
                    "deprecated": true
                  },
                  "role_id": {
                    "type": "string",
                    "description": "Identifier of the role. Defaults to a UUID."
                  },
                  "secret_id_bound_cidrs": {
                    "type": "array",
                    "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "secret_id_num_uses": {
                    "type": "integer",
                    "description": "Number of times a SecretID can access the role, after which the SecretID will expire. Defaults to 0 meaning that the the secret_id is of unlimited use."
                  },
                  "secret_id_ttl": {
                    "type": "integer",
                    "description": "Duration in seconds after which the issued SecretID should expire. Defaults to 0, meaning no expiration.",
                    "format": "seconds"
                  },
                  "token_bound_cidrs": {
                    "type": "array",
                    "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
                    "items": {
                      "type": "string"
                    },
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Bound CIDRs",
                      "group": "Tokens"
                    }
                  },
                  "token_explicit_max_ttl": {
                    "type": "integer",
                    "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Explicit Maximum TTL",
                      "group": "Tokens"
                    }
                  },
                  "token_max_ttl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Maximum TTL",
                      "group": "Tokens"
                    }
                  },
                  "token_no_default_policy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens",
                    "x-vault-displayAttrs": {
                      "name": "Do Not Attach 'default' Policy To Generated Tokens",
                      "group": "Tokens"
                    }
                  },
                  "token_num_uses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited",
                    "x-vault-displayAttrs": {
                      "name": "Maximum Uses of Generated Tokens",
                      "group": "Tokens"
                    }
                  },
                  "token_period": {
                    "type": "integer",
                    "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Period",
                      "group": "Tokens"
                    }
                  },
                  "token_policies": {
                    "type": "array",
                    "description": "Comma-separated list of policies",
                    "items": {
                      "type": "string"
                    },
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Policies",
                      "group": "Tokens"
                    }
                  },
                  "token_ttl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Initial TTL",
                      "group": "Tokens"
                    }
                  },
                  "token_type": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch",
                    "default": "default-service",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Type",
                      "group": "Tokens"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Register an role with the backend.",
        "operationId": "deleteAuthApproleRoleRole_name",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/bind-secret-id": {
      "description": "Impose secret_id to be presented during login using this role.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Impose secret_id to be presented during login using this role.",
        "operationId": "getAuthApproleRoleRole_nameBindSecretId",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Impose secret_id to be presented during login using this role.",
        "operationId": "postAuthApproleRoleRole_nameBindSecretId",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "bind_secret_id": {
                    "type": "boolean",
                    "description": "Impose secret_id to be presented when logging in using this role.",
                    "default": true
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Impose secret_id to be presented during login using this role.",
        "operationId": "deleteAuthApproleRoleRole_nameBindSecretId",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/bound-cidr-list": {
      "description": "Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP\naddresses which can perform the login operation",
        "operationId": "getAuthApproleRoleRole_nameBoundCidrList",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP\naddresses which can perform the login operation",
        "operationId": "postAuthApproleRoleRole_nameBoundCidrList",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "bound_cidr_list": {
                    "type": "array",
                    "description": "Deprecated: Please use \"secret_id_bound_cidrs\" instead. Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP\naddresses which can perform the login operation",
        "operationId": "deleteAuthApproleRoleRole_nameBoundCidrList",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/custom-secret-id": {
      "description": "Assign a SecretID of choice against the role.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Assign a SecretID of choice against the role.",
        "operationId": "postAuthApproleRoleRole_nameCustomSecretId",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "cidr_list": {
                    "type": "array",
                    "description": "Comma separated string or list of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "metadata": {
                    "type": "string",
                    "description": "Metadata to be tied to the SecretID. This should be a JSON formatted string containing metadata in key value pairs."
                  },
                  "secret_id": {
                    "type": "string",
                    "description": "SecretID to be attached to the role."
                  },
                  "token_bound_cidrs": {
                    "type": "array",
                    "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. Should be a subset of the token CIDR blocks listed on the role, if any.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/local-secret-ids": {
      "description": "Enables cluster local secret IDs",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Enables cluster local secret IDs",
        "operationId": "getAuthApproleRoleRole_nameLocalSecretIds",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/period": {
      "description": "Updates the value of 'period' on the role",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Updates the value of 'period' on the role",
        "operationId": "getAuthApproleRoleRole_namePeriod",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Updates the value of 'period' on the role",
        "operationId": "postAuthApproleRoleRole_namePeriod",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "period": {
                    "type": "integer",
                    "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
                    "format": "seconds",
                    "deprecated": true
                  },
                  "token_period": {
                    "type": "integer",
                    "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
                    "format": "seconds"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Updates the value of 'period' on the role",
        "operationId": "deleteAuthApproleRoleRole_namePeriod",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/policies": {
      "description": "Policies of the role.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Policies of the role.",
        "operationId": "getAuthApproleRoleRole_namePolicies",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Policies of the role.",
        "operationId": "postAuthApproleRoleRole_namePolicies",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "policies": {
                    "type": "array",
                    "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
                    "items": {
                      "type": "string"
                    },
                    "deprecated": true
                  },
                  "token_policies": {
                    "type": "array",
                    "description": "Comma-separated list of policies",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Policies of the role.",
        "operationId": "deleteAuthApproleRoleRole_namePolicies",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/role-id": {
      "description": "Returns the 'role_id' of the role.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Returns the 'role_id' of the role.",
        "operationId": "getAuthApproleRoleRole_nameRoleId",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Returns the 'role_id' of the role.",
        "operationId": "postAuthApproleRoleRole_nameRoleId",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "role_id": {
                    "type": "string",
                    "description": "Identifier of the role. Defaults to a UUID."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/secret-id": {
      "description": "Generate a SecretID against this role.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Generate a SecretID against this role.",
        "operationId": "getAuthApproleRoleRole_nameSecretId",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Generate a SecretID against this role.",
        "operationId": "postAuthApproleRoleRole_nameSecretId",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "cidr_list": {
                    "type": "array",
                    "description": "Comma separated string or list of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "metadata": {
                    "type": "string",
                    "description": "Metadata to be tied to the SecretID. This should be a JSON formatted string containing the metadata in key value pairs."
                  },
                  "token_bound_cidrs": {
                    "type": "array",
                    "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/secret-id-accessor/destroy": {
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "postAuthApproleRoleRole_nameSecretIdAccessorDestroy",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "secret_id_accessor": {
                    "type": "string",
                    "description": "Accessor of the SecretID"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "deleteAuthApproleRoleRole_nameSecretIdAccessorDestroy",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/secret-id-accessor/lookup": {
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "postAuthApproleRoleRole_nameSecretIdAccessorLookup",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "secret_id_accessor": {
                    "type": "string",
                    "description": "Accessor of the SecretID"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/secret-id-bound-cidrs": {
      "description": "Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Comma separated list of CIDR blocks, if set, specifies blocks of IP\naddresses which can perform the login operation",
        "operationId": "getAuthApproleRoleRole_nameSecretIdBoundCidrs",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Comma separated list of CIDR blocks, if set, specifies blocks of IP\naddresses which can perform the login operation",
        "operationId": "postAuthApproleRoleRole_nameSecretIdBoundCidrs",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "secret_id_bound_cidrs": {
                    "type": "array",
                    "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Comma separated list of CIDR blocks, if set, specifies blocks of IP\naddresses which can perform the login operation",
        "operationId": "deleteAuthApproleRoleRole_nameSecretIdBoundCidrs",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/secret-id-num-uses": {
      "description": "Use limit of the SecretID generated against the role.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Use limit of the SecretID generated against the role.",
        "operationId": "getAuthApproleRoleRole_nameSecretIdNumUses",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Use limit of the SecretID generated against the role.",
        "operationId": "postAuthApproleRoleRole_nameSecretIdNumUses",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "secret_id_num_uses": {
                    "type": "integer",
                    "description": "Number of times a SecretID can access the role, after which the SecretID will expire."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Use limit of the SecretID generated against the role.",
        "operationId": "deleteAuthApproleRoleRole_nameSecretIdNumUses",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/secret-id-ttl": {
      "description": "Duration in seconds, representing the lifetime of the SecretIDs that are generated against the role using 'role/<role_name>/secret-id' or 'role/<role_name>/custom-secret-id' endpoints.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Duration in seconds, representing the lifetime of the SecretIDs\nthat are generated against the role using 'role/<role_name>/secret-id' or\n'role/<role_name>/custom-secret-id' endpoints.",
        "operationId": "getAuthApproleRoleRole_nameSecretIdTtl",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Duration in seconds, representing the lifetime of the SecretIDs\nthat are generated against the role using 'role/<role_name>/secret-id' or\n'role/<role_name>/custom-secret-id' endpoints.",
        "operationId": "postAuthApproleRoleRole_nameSecretIdTtl",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "secret_id_ttl": {
                    "type": "integer",
                    "description": "Duration in seconds after which the issued SecretID should expire. Defaults to 0, meaning no expiration.",
                    "format": "seconds"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Duration in seconds, representing the lifetime of the SecretIDs\nthat are generated against the role using 'role/<role_name>/secret-id' or\n'role/<role_name>/custom-secret-id' endpoints.",
        "operationId": "deleteAuthApproleRoleRole_nameSecretIdTtl",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/secret-id/destroy": {
      "description": "Invalidate an issued secret_id",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Invalidate an issued secret_id",
        "operationId": "postAuthApproleRoleRole_nameSecretIdDestroy",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "secret_id": {
                    "type": "string",
                    "description": "SecretID attached to the role."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Invalidate an issued secret_id",
        "operationId": "deleteAuthApproleRoleRole_nameSecretIdDestroy",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/secret-id/lookup": {
      "description": "Read the properties of an issued secret_id",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Read the properties of an issued secret_id",
        "operationId": "postAuthApproleRoleRole_nameSecretIdLookup",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "secret_id": {
                    "type": "string",
                    "description": "SecretID attached to the role."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/token-bound-cidrs": {
      "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of\nIP addresses which can use the returned token.",
        "operationId": "getAuthApproleRoleRole_nameTokenBoundCidrs",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of\nIP addresses which can use the returned token.",
        "operationId": "postAuthApproleRoleRole_nameTokenBoundCidrs",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token_bound_cidrs": {
                    "type": "array",
                    "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of\nIP addresses which can use the returned token.",
        "operationId": "deleteAuthApproleRoleRole_nameTokenBoundCidrs",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/token-max-ttl": {
      "description": "Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Duration in seconds, the maximum lifetime of the tokens issued by using\nthe SecretIDs that were generated against this role, after which the\ntokens are not allowed to be renewed.",
        "operationId": "getAuthApproleRoleRole_nameTokenMaxTtl",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Duration in seconds, the maximum lifetime of the tokens issued by using\nthe SecretIDs that were generated against this role, after which the\ntokens are not allowed to be renewed.",
        "operationId": "postAuthApproleRoleRole_nameTokenMaxTtl",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token_max_ttl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token",
                    "format": "seconds"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Duration in seconds, the maximum lifetime of the tokens issued by using\nthe SecretIDs that were generated against this role, after which the\ntokens are not allowed to be renewed.",
        "operationId": "deleteAuthApproleRoleRole_nameTokenMaxTtl",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/token-num-uses": {
      "description": "Number of times issued tokens can be used",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Number of times issued tokens can be used",
        "operationId": "getAuthApproleRoleRole_nameTokenNumUses",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Number of times issued tokens can be used",
        "operationId": "postAuthApproleRoleRole_nameTokenNumUses",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token_num_uses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Number of times issued tokens can be used",
        "operationId": "deleteAuthApproleRoleRole_nameTokenNumUses",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/role/{role_name}/token-ttl": {
      "description": "Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Duration in seconds, the lifetime of the token issued by using the SecretID that\nis generated against this role, before which the token needs to be renewed.",
        "operationId": "getAuthApproleRoleRole_nameTokenTtl",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Duration in seconds, the lifetime of the token issued by using the SecretID that\nis generated against this role, before which the token needs to be renewed.",
        "operationId": "postAuthApproleRoleRole_nameTokenTtl",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token_ttl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate",
                    "format": "seconds"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Duration in seconds, the lifetime of the token issued by using the SecretID that\nis generated against this role, before which the token needs to be renewed.",
        "operationId": "deleteAuthApproleRoleRole_nameTokenTtl",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/approle/tidy/secret-id": {
      "description": "Trigger the clean-up of expired SecretID entries.",
      "post": {
        "summary": "Trigger the clean-up of expired SecretID entries.",
        "operationId": "postAuthApproleTidySecretId",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/auth_method": {
      "description": "Lists all the roles registered with the backend.",
      "get": {
        "summary": "Lists all the roles registered with the backend.",
        "description": "The list will contain the names of the roles.",
        "operationId": "getAuthFlant_iam_authAuth_method",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/auth_method/{name}": {
      "description": "Register an authMethodConfig with the backend.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the authMethodConfig.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read an existing authMethodConfig.",
        "operationId": "getAuthFlant_iam_authAuth_methodName",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register an authMethodConfig with the backend.",
        "description": "A authMethodConfig is required to authenticate with this backend. The authMethodConfig binds\n\t\tJWT token information with token policies and settings.\n\t\tThe bindings, token polices and token settings can all be configured\n\t\tusing this endpoint",
        "operationId": "postAuthFlant_iam_authAuth_methodName",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allowed_redirect_uris": {
                    "type": "array",
                    "description": "Comma-separated list of allowed values for redirect_uri",
                    "items": {
                      "type": "string"
                    }
                  },
                  "bound_audiences": {
                    "type": "array",
                    "description": "Comma-separated list of 'aud' claims that are valid for login; any match is sufficient",
                    "items": {
                      "type": "string"
                    }
                  },
                  "bound_claims": {
                    "type": "object",
                    "description": "Map of claims/values which must match for login",
                    "format": "map"
                  },
                  "bound_claims_type": {
                    "type": "string",
                    "description": "How to interpret values in the map of claims/values (which must match for login): allowed values are 'string' or 'glob'"
                  },
                  "bound_subject": {
                    "type": "string",
                    "description": "The 'sub' claim that is valid for login. Optional."
                  },
                  "claim_mappings": {
                    "type": "object",
                    "description": "Mappings of claims (key) that will be copied to a metadata field (value)",
                    "format": "kvpairs"
                  },
                  "clock_skew_leeway": {
                    "type": "integer",
                    "description": "Duration in seconds of leeway when validating all claims to account for clock skew. Defaults to 60 (1 minute) if set to 0 and can be disabled if set to -1.",
                    "format": "seconds",
                    "default": 60000000000
                  },
                  "expiration_leeway": {
                    "type": "integer",
                    "description": "Duration in seconds of leeway when validating expiration of a token to account for clock skew. Defaults to 150 (2.5 minutes) if set to 0 and can be disabled if set to -1.",
                    "format": "seconds",
                    "default": 150
                  },
                  "groups_claim": {
                    "type": "string",
                    "description": "The claim to use for the Identity group alias names"
                  },
                  "max_age": {
                    "type": "integer",
                    "description": "Specifies the allowable elapsed time in seconds since the last time the user was actively authenticated.",
                    "format": "seconds"
                  },
                  "method_type": {
                    "type": "string",
                    "description": "Type of the authMethodConfig, either 'jwt', 'oidc', 'service_account_password' or 'multipass_jwt'."
                  },
                  "not_before_leeway": {
                    "type": "integer",
                    "description": "Duration in seconds of leeway when validating not before values of a token to account for clock skew. Defaults to 150 (2.5 minutes) if set to 0 and can be disabled if set to -1.",
                    "format": "seconds",
                    "default": 150
                  },
                  "oidc_scopes": {
                    "type": "array",
                    "description": "Comma-separated list of OIDC scopes",
                    "items": {
                      "type": "string"
                    }
                  },
                  "source": {
                    "type": "string",
                    "description": "authentification source for method thypes 'jwt' and 'oidc'."
                  },
                  "token_bound_cidrs": {
                    "type": "array",
                    "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
                    "items": {
                      "type": "string"
                    },
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Bound CIDRs",
                      "group": "Tokens"
                    }
                  },
                  "token_explicit_max_ttl": {
                    "type": "integer",
                    "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Explicit Maximum TTL",
                      "group": "Tokens"
                    }
                  },
                  "token_max_ttl": {
                    "type": "integer",
                    "description": "The maximum lifetime of the generated token",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Maximum TTL",
                      "group": "Tokens"
                    }
                  },
                  "token_no_default_policy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens",
                    "x-vault-displayAttrs": {
                      "name": "Do Not Attach 'default' Policy To Generated Tokens",
                      "group": "Tokens"
                    }
                  },
                  "token_num_uses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited",
                    "x-vault-displayAttrs": {
                      "name": "Maximum Uses of Generated Tokens",
                      "group": "Tokens"
                    }
                  },
                  "token_period": {
                    "type": "integer",
                    "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Period",
                      "group": "Tokens"
                    }
                  },
                  "token_policies": {
                    "type": "array",
                    "description": "Comma-separated list of policies",
                    "items": {
                      "type": "string"
                    },
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Policies",
                      "group": "Tokens"
                    }
                  },
                  "token_ttl": {
                    "type": "integer",
                    "description": "The initial ttl of the token to generate",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Initial TTL",
                      "group": "Tokens"
                    }
                  },
                  "token_type": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch",
                    "default": "default-service",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Type",
                      "group": "Tokens"
                    }
                  },
                  "user_claim": {
                    "type": "string",
                    "description": "The claim to use for the Identity entity alias name"
                  },
                  "verbose_oidc_logging": {
                    "type": "boolean",
                    "description": "Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive information may be present in OIDC responses."
                  }
                },
                "required": [
                  "method_type"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete an existing authMethodConfig.",
        "operationId": "deleteAuthFlant_iam_authAuth_methodName",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/flant_iam_auth/auth_source": {
      "get": {
        "summary": "Delete authentication source.",
        "description": "The JWT authentication backend validates JWTs (or OIDC) using the configured\ncredentials. If using OIDC Discovery, the URL must be provided, along\nwith (optionally) the CA cert to use for the connection. If performing JWT\nvalidation locally, a set of public keys must be provided.",
        "operationId": "getAuthFlant_iam_authAuth_source",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/auth_source/{name}": {
      "description": "Configures the JWT authentication backend.",
      "parameters": [
        {
          "name": "name",
          "description": "auth source name",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read authentication source.",
        "operationId": "getAuthFlant_iam_authAuth_sourceName",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Write authentication source name passed name.",
        "operationId": "postAuthFlant_iam_authAuth_sourceName",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_service_accounts": {
                    "type": "boolean",
                    "description": "Allow create entity aliases for services accounts fot this source",
                    "default": false
                  },
                  "bound_issuer": {
                    "type": "string",
                    "description": "The value against which to match the 'iss' claim in a JWT. Optional."
                  },
                  "default_role": {
                    "type": "string",
                    "description": "The default authMethodConfig to use if none is provided during login. If not set, a authMethodConfig is required during login.",
                    "format": "lowercase"
                  },
                  "entity_alias_name": {
                    "type": "string",
                    "description": "entity alias name source. may be 'email', 'full_identifier', or 'uuid'."
                  },
                  "jwks_ca_pem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used."
                  },
                  "jwks_url": {
                    "type": "string",
                    "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\"."
                  },
                  "jwt_supported_algs": {
                    "type": "array",
                    "description": "A list of supported signing algorithms. Defaults to RS256.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "jwt_validation_pubkeys": {
                    "type": "array",
                    "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used with \"jwks_url\" or \"oidc_discovery_url\".",
                    "items": {
                      "type": "string"
                    }
                  },
                  "namespace_in_state": {
                    "type": "boolean",
                    "description": "Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs.",
                    "x-vault-displayAttrs": {
                      "name": "Namespace in OIDC state",
                      "value": true
                    }
                  },
                  "oidc_client_id": {
                    "type": "string",
                    "description": "The OAuth Client ID configured with your OIDC provider."
                  },
                  "oidc_client_secret": {
                    "type": "string",
                    "description": "The OAuth Client Secret configured with your OIDC provider.",
                    "x-vault-displayAttrs": {
                      "sensitive": true
                    }
                  },
                  "oidc_discovery_ca_pem": {
                    "type": "string",
                    "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used."
                  },
                  "oidc_discovery_url": {
                    "type": "string",
                    "description": "OIDC Discovery URL, without any .well-known component (base path). Cannot be used with \"jwks_url\" or \"jwt_validation_pubkeys\"."
                  },
                  "oidc_response_mode": {
                    "type": "string",
                    "description": "The response mode to be used in the OAuth2 request. Allowed values are 'query' and 'form_post'."
                  },
                  "oidc_response_types": {
                    "type": "array",
                    "description": "The response types to request. Allowed values are 'code' and 'id_token'. Defaults to 'code'.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "provider_config": {
                    "type": "object",
                    "description": "Provider-specific configuration. Optional.",
                    "format": "map",
                    "x-vault-displayAttrs": {
                      "name": "Provider Config"
                    }
                  }
                },
                "required": [
                  "entity_alias_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete authentication source.",
        "description": "The JWT authentication backend validates JWTs (or OIDC) using the configured\ncredentials. If using OIDC Discovery, the URL must be provided, along\nwith (optionally) the CA cert to use for the connection. If performing JWT\nvalidation locally, a set of public keys must be provided.",
        "operationId": "deleteAuthFlant_iam_authAuth_sourceName",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/flant_iam_auth/configure_extension/server_access": {
      "post": {
        "summary": "Register server extension",
        "operationId": "postAuthFlant_iam_authConfigure_extensionServer_access",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "role_for_ssh_access": {
                    "type": "string",
                    "description": "Role to use for SSH access",
                    "default": "ssh"
                  }
                },
                "required": [
                  "role_for_ssh_access"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/configure_vault_access": {
      "description": "Configure vault access to itself",
      "post": {
        "summary": "Configure vault access to itself",
        "operationId": "postAuthFlant_iam_authConfigure_vault_access",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "approle_mount_point": {
                    "type": "string",
                    "description": "Approle mount point for getting new token and renew it"
                  },
                  "role_id": {
                    "type": "string",
                    "description": "Role id for approle"
                  },
                  "role_name": {
                    "type": "string",
                    "description": "Role name to vault access"
                  },
                  "secret_id": {
                    "type": "string",
                    "description": "Secret to access approle"
                  },
                  "secret_id_ttl": {
                    "type": "integer",
                    "description": "Secret id time to life. Min 120s (2 minutes)",
                    "format": "seconds"
                  },
                  "token_ttl": {
                    "type": "integer",
                    "description": "Token id time to life. Min 20s",
                    "format": "seconds"
                  },
                  "vault_addr": {
                    "type": "string",
                    "description": "Url for connect to vault api"
                  },
                  "vault_cacert": {
                    "type": "string",
                    "description": "Vault CA cert using for TLS verification. In PEM format",
                    "default": "limbo"
                  },
                  "vault_tls_server_name": {
                    "type": "string",
                    "description": "Connection host. Uses as \"Host\" header in vault client"
                  }
                },
                "required": [
                  "vault_cacert",
                  "secret_id",
                  "vault_tls_server_name",
                  "token_ttl",
                  "approle_mount_point",
                  "role_name",
                  "vault_addr",
                  "role_id",
                  "secret_id_ttl"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/issue/jwt/{name}": {
      "description": "Issue options as jwt token",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the jwt type",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Update an existing jwt type",
        "operationId": "postAuthFlant_iam_authIssueJwtName",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "options": {
                    "type": "object",
                    "description": "Options for jwt type sign",
                    "format": "map"
                  }
                },
                "required": [
                  "options"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/issue/multipass_jwt/{uuid}": {
      "description": "Issue multipass jwt token with new generation number",
      "parameters": [
        {
          "name": "uuid",
          "description": "Name of the jwt type",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Update an existing jwt type",
        "operationId": "postAuthFlant_iam_authIssueMultipass_jwtUuid",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/jwks": {
      "description": "Endpoint to expose public keys to check authority of issued tokens.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Endpoint to expose public keys to check authority of issued tokens.",
        "operationId": "getAuthFlant_iam_authJwks",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/jwt/configure": {
      "description": "Configure JWT options.",
      "get": {
        "summary": "Read JWT issuing status and configuration.",
        "operationId": "getAuthFlant_iam_authJwtConfigure",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure JWT options.",
        "operationId": "postAuthFlant_iam_authJwtConfigure",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. The issuer is a case sensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components, but no query or fragment components.",
                    "default": "https://auth.negentropy.flant.com/"
                  },
                  "multipass_audience": {
                    "type": "string",
                    "description": "Value of the audience claim.",
                    "default": "limbo"
                  },
                  "preliminary_announce_period": {
                    "type": "integer",
                    "description": "Publish the key in advance after specified amount of time.",
                    "format": "seconds",
                    "default": "1d"
                  },
                  "rotation_period": {
                    "type": "integer",
                    "description": "Force rotate public/private key pair.",
                    "format": "seconds",
                    "default": "1d"
                  }
                },
                "required": [
                  "rotation_period",
                  "preliminary_announce_period",
                  "issuer",
                  "multipass_audience"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/jwt/disable": {
      "description": "Disable JWT issuing.",
      "post": {
        "summary": "Disable JWT issuing.",
        "operationId": "postAuthFlant_iam_authJwtDisable",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/jwt/enable": {
      "description": "Enable JWT issuing.",
      "post": {
        "summary": "Enable JWT issuing.",
        "operationId": "postAuthFlant_iam_authJwtEnable",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/jwt/rotate_key": {
      "description": "Force key rotation. Calling this endpoint will rotate keys immediately.",
      "post": {
        "summary": "Force key rotation. Calling this endpoint will rotate keys immediately.",
        "operationId": "postAuthFlant_iam_authJwtRotate_key",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/jwt_type": {
      "get": {
        "summary": "Lists all jwt types registered with the backend",
        "description": "The list will contain the names of the jwt token types.",
        "operationId": "getAuthFlant_iam_authJwt_type",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/jwt_type/{name}": {
      "description": "Manage jwt token types",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the jwt type",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read an existing jwt type",
        "operationId": "getAuthFlant_iam_authJwt_typeName",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update an existing jwt type",
        "operationId": "postAuthFlant_iam_authJwt_typeName",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "options_schema": {
                    "type": "string",
                    "description": "OpenApi schema for validating issuer params"
                  },
                  "ttl": {
                    "type": "integer",
                    "description": "Time to life (in seconds) for signed jwt token",
                    "format": "seconds"
                  }
                },
                "required": [
                  "ttl"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete an existing jwt type",
        "operationId": "deleteAuthFlant_iam_authJwt_typeName",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/flant_iam_auth/kafka/configure": {
      "x-vault-createSupported": true,
      "post": {
        "summary": "Setup kafka plugin configuration",
        "operationId": "postAuthFlant_iam_authKafkaConfigure",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "peers_public_keys": {
                    "type": "array",
                    "description": "Vault public keys to check signature in JWKS and TokenGenerationNumber topics",
                    "items": {
                      "type": "string"
                    }
                  },
                  "publish_quota_usage": {
                    "type": "boolean",
                    "default": false
                  },
                  "root_public_key": {
                    "type": "string",
                    "description": "RootVault public key for replication"
                  },
                  "root_topic_name": {
                    "type": "string",
                    "description": "RootVault replication topic name"
                  },
                  "self_topic_name": {
                    "type": "string",
                    "description": "Self restore topic name"
                  }
                },
                "required": [
                  "self_topic_name",
                  "root_public_key",
                  "root_topic_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/kafka/configure_access": {
      "post": {
        "summary": "Setup kafka configuration",
        "operationId": "postAuthFlant_iam_authKafkaConfigure_access",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "certificate": {
                    "type": "string",
                    "description": "x509 certificate to establish Kafka TLS connection"
                  },
                  "kafka_endpoints": {
                    "type": "array",
                    "description": "List of kafka backends. Ex: 192.168.1.1:9093",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "kafka_endpoints"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/kafka/generate_csr": {
      "parameters": [
        {
          "name": "force",
          "description": "Enforce private key recreation",
          "in": "query",
          "schema": {
            "type": "boolean",
            "default": false
          }
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Generate CSR for kafka endpoint",
        "operationId": "postAuthFlant_iam_authKafkaGenerate_csr",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/kafka/public_key": {
      "get": {
        "summary": "Return public key",
        "operationId": "getAuthFlant_iam_authKafkaPublic_key",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/login": {
      "description": "Authenticates to Vault using a JWT (or OIDC) token.",
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Authenticates to Vault using a JWT (or OIDC) token.",
        "operationId": "postAuthFlant_iam_authLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "jwt": {
                    "type": "string",
                    "description": "The signed JWT (or multipass jwt) to validate."
                  },
                  "method": {
                    "type": "string",
                    "description": "The auth method.",
                    "format": "lowercase"
                  },
                  "roles": {
                    "type": "array",
                    "description": "Requested roles",
                    "items": {
                      "type": "object"
                    }
                  },
                  "service_account_password_secret": {
                    "type": "string",
                    "description": "Service account password secret. Used for service account password auth"
                  },
                  "service_account_password_uuid": {
                    "type": "string",
                    "description": "Service account password uuid. Used for service account password auth"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/vst_owner": {
      "description": "Provide info about owner of multipass",
      "get": {
        "summary": "Authenticates to Vault using a JWT (or OIDC) token.",
        "operationId": "getAuthFlant_iam_authMultipass_owner",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/oidc/auth_url": {
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Request an authorization URL to start an OIDC login flow.",
        "operationId": "postAuthFlant_iam_authOidcAuth_url",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "authMethodName": {
                    "type": "string",
                    "description": "The authMethodConfig to issue an OIDC authorization URL against.",
                    "format": "lowercase"
                  },
                  "client_nonce": {
                    "type": "string",
                    "description": "Optional client-provided nonce that must match during callback, if present."
                  },
                  "redirect_uri": {
                    "type": "string",
                    "description": "The OAuth redirect_uri to use in the authorization URL."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/oidc/callback": {
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Callback endpoint to complete an OIDC login.",
        "operationId": "getAuthFlant_iam_authOidcCallback",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Callback endpoint to handle form_posts.",
        "operationId": "postAuthFlant_iam_authOidcCallback",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "client_nonce": {
                    "type": "string"
                  },
                  "code": {
                    "type": "string"
                  },
                  "id_token": {
                    "type": "string"
                  },
                  "state": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/query_server": {
      "parameters": [
        {
          "name": "labelSelector",
          "description": "label selector",
          "in": "query",
          "schema": {
            "type": "string"
          }
        }
      ],
      "get": {
        "summary": "Query servers by labels",
        "operationId": "getAuthFlant_iam_authQuery_server",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/tenant": {
      "get": {
        "summary": "List all tenants.",
        "operationId": "getAuthFlant_iam_authTenant",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/tenant/{tenant_uuid}/project": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "UUID of a tenant",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "List all projects of a tenant.",
        "operationId": "getAuthFlant_iam_authTenantTenant_uuidProject",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/tenant/{tenant_uuid}/project/{project_uuid}/query_server": {
      "parameters": [
        {
          "name": "labelSelector",
          "description": "label selector",
          "in": "query",
          "schema": {
            "type": "string"
          }
        },
        {
          "name": "names",
          "description": "server names array",
          "in": "query",
          "schema": {
            "type": "array"
          }
        },
        {
          "name": "project_uuid",
          "description": "UUID of a project",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "UUID of a tenant",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Query servers in project by names or labels",
        "operationId": "getAuthFlant_iam_authTenantTenant_uuidProjectProject_uuidQuery_server",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/tenant/{tenant_uuid}/project/{project_uuid}/server/{server_uuid}/posix_users": {
      "parameters": [
        {
          "name": "project_uuid",
          "description": "UUID of a project",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "server_uuid",
          "description": "UUID of a server",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "UUID of a tenant",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "GET all posix users",
        "operationId": "getAuthFlant_iam_authTenantTenant_uuidProjectProject_uuidServerServer_uuidPosix_users",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/tenant/{tenant_uuid}/project/{uuid}": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a project",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the project by ID.",
        "operationId": "getAuthFlant_iam_authTenantTenant_uuidProjectUuid",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/tenant/{tenant_uuid}/query_server": {
      "parameters": [
        {
          "name": "labelSelector",
          "description": "label selector",
          "in": "query",
          "schema": {
            "type": "string"
          }
        },
        {
          "name": "tenant_uuid",
          "description": "UUID of a tenant",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Query servers in tenant by labels",
        "operationId": "getAuthFlant_iam_authTenantTenant_uuidQuery_server",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/flant_iam_auth/tenant/{uuid}": {
      "parameters": [
        {
          "name": "uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the tenant by ID.",
        "operationId": "getAuthFlant_iam_authTenantUuid",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/accessors/": {
      "description": "List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires 'sudo' capability in addition to 'list'.",
      "x-vault-sudo": true,
      "get": {
        "summary": "List token accessors, which can then be\nbe used to iterate and discover their properties\nor revoke them. Because this can be used to\ncause a denial of service, this endpoint\nrequires 'sudo' capability in addition to\n'list'.",
        "operationId": "getAuthTokenAccessors",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/create": {
      "description": "The token create path is used to create new tokens.",
      "post": {
        "summary": "The token create path is used to create new tokens.",
        "operationId": "postAuthTokenCreate",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/create-orphan": {
      "description": "The token create path is used to create new orphan tokens.",
      "post": {
        "summary": "The token create path is used to create new orphan tokens.",
        "operationId": "postAuthTokenCreateOrphan",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/create/{role_name}": {
      "description": "This token create path is used to create new tokens adhering to the given role.",
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "This token create path is used to create new tokens adhering to the given role.",
        "operationId": "postAuthTokenCreateRole_name",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/lookup": {
      "description": "This endpoint will lookup a token and its properties.",
      "get": {
        "summary": "This endpoint will lookup a token and its properties.",
        "operationId": "getAuthTokenLookup",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "This endpoint will lookup a token and its properties.",
        "operationId": "postAuthTokenLookup",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "type": "string",
                    "description": "Token to lookup (POST request body)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/lookup-accessor": {
      "description": "This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.",
      "post": {
        "summary": "This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.",
        "operationId": "postAuthTokenLookupAccessor",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "accessor": {
                    "type": "string",
                    "description": "Accessor of the token to look up (request body)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/lookup-self": {
      "description": "This endpoint will lookup a token and its properties.",
      "get": {
        "summary": "This endpoint will lookup a token and its properties.",
        "operationId": "getAuthTokenLookupSelf",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "This endpoint will lookup a token and its properties.",
        "operationId": "postAuthTokenLookupSelf",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "type": "string",
                    "description": "Token to look up (unused, does not need to be set)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/renew": {
      "description": "This endpoint will renew the given token and prevent expiration.",
      "post": {
        "summary": "This endpoint will renew the given token and prevent expiration.",
        "operationId": "postAuthTokenRenew",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "increment": {
                    "type": "integer",
                    "description": "The desired increment in seconds to the token expiration",
                    "format": "seconds",
                    "default": 0
                  },
                  "token": {
                    "type": "string",
                    "description": "Token to renew (request body)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/renew-accessor": {
      "description": "This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.",
      "post": {
        "summary": "This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.",
        "operationId": "postAuthTokenRenewAccessor",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "accessor": {
                    "type": "string",
                    "description": "Accessor of the token to renew (request body)"
                  },
                  "increment": {
                    "type": "integer",
                    "description": "The desired increment in seconds to the token expiration",
                    "format": "seconds",
                    "default": 0
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/renew-self": {
      "description": "This endpoint will renew the token used to call it and prevent expiration.",
      "post": {
        "summary": "This endpoint will renew the token used to call it and prevent expiration.",
        "operationId": "postAuthTokenRenewSelf",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "increment": {
                    "type": "integer",
                    "description": "The desired increment in seconds to the token expiration",
                    "format": "seconds",
                    "default": 0
                  },
                  "token": {
                    "type": "string",
                    "description": "Token to renew (unused, does not need to be set)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/revoke": {
      "description": "This endpoint will delete the given token and all of its child tokens.",
      "post": {
        "summary": "This endpoint will delete the given token and all of its child tokens.",
        "operationId": "postAuthTokenRevoke",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "type": "string",
                    "description": "Token to revoke (request body)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/revoke-accessor": {
      "description": "This endpoint will delete the token associated with the accessor and all of its child tokens.",
      "post": {
        "summary": "This endpoint will delete the token associated with the accessor and all of its child tokens.",
        "operationId": "postAuthTokenRevokeAccessor",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "accessor": {
                    "type": "string",
                    "description": "Accessor of the token (request body)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/revoke-orphan": {
      "description": "This endpoint will delete the token and orphan its child tokens.",
      "post": {
        "summary": "This endpoint will delete the token and orphan its child tokens.",
        "operationId": "postAuthTokenRevokeOrphan",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "type": "string",
                    "description": "Token to revoke (request body)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/revoke-self": {
      "description": "This endpoint will delete the token used to call it and all of its child tokens.",
      "post": {
        "summary": "This endpoint will delete the token used to call it and all of its child tokens.",
        "operationId": "postAuthTokenRevokeSelf",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/roles": {
      "description": "This endpoint lists configured roles.",
      "get": {
        "summary": "This endpoint lists configured roles.",
        "operationId": "getAuthTokenRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/token/roles/{role_name}": {
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "getAuthTokenRolesRole_name",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "postAuthTokenRolesRole_name",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allowed_entity_aliases": {
                    "type": "array",
                    "description": "String or JSON list of allowed entity aliases. If set, specifies the entity aliases which are allowed to be used during token generation. This field supports globbing.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "allowed_policies": {
                    "type": "array",
                    "description": "If set, tokens can be created with any subset of the policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy names.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "bound_cidrs": {
                    "type": "array",
                    "description": "Use 'token_bound_cidrs' instead.",
                    "items": {
                      "type": "string"
                    },
                    "deprecated": true
                  },
                  "disallowed_policies": {
                    "type": "array",
                    "description": "If set, successful token creation via this role will require that no policies in the given list are requested. The parameter is a comma-delimited string of policy names.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "explicit_max_ttl": {
                    "type": "integer",
                    "description": "Use 'token_explicit_max_ttl' instead.",
                    "format": "seconds",
                    "deprecated": true
                  },
                  "orphan": {
                    "type": "boolean",
                    "description": "If true, tokens created via this role will be orphan tokens (have no parent)"
                  },
                  "path_suffix": {
                    "type": "string",
                    "description": "If set, tokens created via this role will contain the given suffix as a part of their path. This can be used to assist use of the 'revoke-prefix' endpoint later on. The given suffix must match the regular expression.\\w[\\w-.]+\\w"
                  },
                  "period": {
                    "type": "integer",
                    "description": "Use 'token_period' instead.",
                    "format": "seconds",
                    "deprecated": true
                  },
                  "renewable": {
                    "type": "boolean",
                    "description": "Tokens created via this role will be renewable or not according to this value. Defaults to \"true\".",
                    "default": true
                  },
                  "token_bound_cidrs": {
                    "type": "array",
                    "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
                    "items": {
                      "type": "string"
                    },
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Bound CIDRs",
                      "group": "Tokens"
                    }
                  },
                  "token_explicit_max_ttl": {
                    "type": "integer",
                    "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Explicit Maximum TTL",
                      "group": "Tokens"
                    }
                  },
                  "token_no_default_policy": {
                    "type": "boolean",
                    "description": "If true, the 'default' policy will not automatically be added to generated tokens",
                    "x-vault-displayAttrs": {
                      "name": "Do Not Attach 'default' Policy To Generated Tokens",
                      "group": "Tokens"
                    }
                  },
                  "token_num_uses": {
                    "type": "integer",
                    "description": "The maximum number of times a token may be used, a value of zero means unlimited",
                    "x-vault-displayAttrs": {
                      "name": "Maximum Uses of Generated Tokens",
                      "group": "Tokens"
                    }
                  },
                  "token_period": {
                    "type": "integer",
                    "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Period",
                      "group": "Tokens"
                    }
                  },
                  "token_type": {
                    "type": "string",
                    "description": "The type of token to generate, service or batch",
                    "default": "default-service",
                    "x-vault-displayAttrs": {
                      "name": "Generated Token's Type",
                      "group": "Tokens"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "deleteAuthTokenRolesRole_name",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/token/tidy": {
      "description": "This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.",
      "post": {
        "summary": "This endpoint performs cleanup tasks that can be run if certain error\nconditions have occurred.",
        "operationId": "postAuthTokenTidy",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/cubbyhole/{path}": {
      "description": "Pass-through secret storage to a token-specific cubbyhole in the storage backend, allowing you to read/write arbitrary data into secret storage.",
      "parameters": [
        {
          "name": "path",
          "description": "Specifies the path of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Retrieve the secret at the specified location.",
        "operationId": "getCubbyholePath",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Store a secret at the specified location.",
        "operationId": "postCubbyholePath",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the secret at the specified location.",
        "operationId": "deleteCubbyholePath",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/client": {
      "get": {
        "summary": "Lists all client IDs.",
        "operationId": "getFlant_iamClient",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/client/privileged": {
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create client with preexistent ID.",
        "operationId": "postFlant_iamClientPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a client",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "identifier",
                  "uuid"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/client/{client_uuid}/contact": {
      "parameters": [
        {
          "name": "client_uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all contacts IDs.",
        "operationId": "getFlant_iamClientClient_uuidContact",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/client/{client_uuid}/contact/privileged": {
      "parameters": [
        {
          "name": "client_uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create contact with preexistent ID.",
        "operationId": "postFlant_iamClientClient_uuidContactPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "additional_emails": {
                    "type": "array",
                    "description": "additional_emails",
                    "items": {
                      "type": "string"
                    }
                  },
                  "additional_phones": {
                    "type": "array",
                    "description": "additional_phones",
                    "items": {
                      "type": "string"
                    }
                  },
                  "credentials": {
                    "type": "object",
                    "description": "credentials per projectUUID, allowed values: \"contact\", \"authorized_contact\", \"representative\", \"plenipotentiary\"",
                    "format": "kvpairs"
                  },
                  "display_name": {
                    "type": "string",
                    "description": "display_name"
                  },
                  "email": {
                    "type": "string",
                    "description": "email"
                  },
                  "first_name": {
                    "type": "string",
                    "description": "first_name"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "last_name": {
                    "type": "string",
                    "description": "last_name"
                  },
                  "mobile_phone": {
                    "type": "string",
                    "description": "mobile_phone"
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a contact",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "identifier",
                  "email",
                  "display_name",
                  "mobile_phone",
                  "additional_phones",
                  "additional_emails",
                  "uuid",
                  "credentials",
                  "first_name",
                  "last_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/client/{client_uuid}/contact/{uuid}": {
      "parameters": [
        {
          "name": "client_uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a contact",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the contact by ID",
        "operationId": "getFlant_iamClientClient_uuidContactUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the contact by ID",
        "operationId": "postFlant_iamClientClient_uuidContactUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "additional_emails": {
                    "type": "array",
                    "description": "additional_emails",
                    "items": {
                      "type": "string"
                    }
                  },
                  "additional_phones": {
                    "type": "array",
                    "description": "additional_phones",
                    "items": {
                      "type": "string"
                    }
                  },
                  "credentials": {
                    "type": "object",
                    "description": "credentials per projectUUID, allowed values: \"contact\", \"authorized_contact\", \"representative\", \"plenipotentiary\"",
                    "format": "kvpairs"
                  },
                  "display_name": {
                    "type": "string",
                    "description": "display_name"
                  },
                  "email": {
                    "type": "string",
                    "description": "email"
                  },
                  "first_name": {
                    "type": "string",
                    "description": "first_name"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "last_name": {
                    "type": "string",
                    "description": "last_name"
                  },
                  "mobile_phone": {
                    "type": "string",
                    "description": "mobile_phone"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  }
                },
                "required": [
                  "additional_emails",
                  "first_name",
                  "display_name",
                  "mobile_phone",
                  "resource_version",
                  "identifier",
                  "email",
                  "additional_phones",
                  "credentials",
                  "last_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the contact by ID",
        "operationId": "deleteFlant_iamClientClient_uuidContactUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/client/{client_uuid}/contact/{uuid}/restore": {
      "parameters": [
        {
          "name": "client_uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a contact",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Restore the contact by ID.",
        "operationId": "postFlant_iamClientClient_uuidContactUuidRestore",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/client/{client_uuid}/project": {
      "parameters": [
        {
          "name": "client_uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all projects IDs.",
        "operationId": "getFlant_iamClientClient_uuidProject",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/client/{client_uuid}/project/privileged": {
      "parameters": [
        {
          "name": "client_uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create project with preexistent ID.",
        "operationId": "postFlant_iamClientClient_uuidProjectPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "service_packs": {
                    "type": "object",
                    "description": "Service packs",
                    "format": "kvpairs"
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a project",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "uuid",
                  "identifier",
                  "service_packs"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/client/{client_uuid}/project/{uuid}": {
      "parameters": [
        {
          "name": "client_uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a project",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the project by ID.",
        "operationId": "getFlant_iamClientClient_uuidProjectUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the project by ID.",
        "operationId": "postFlant_iamClientClient_uuidProjectUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  },
                  "service_packs": {
                    "type": "object",
                    "description": "Service packs",
                    "format": "kvpairs"
                  }
                },
                "required": [
                  "resource_version",
                  "identifier",
                  "service_packs"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the project by ID.",
        "operationId": "deleteFlant_iamClientClient_uuidProjectUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/client/{client_uuid}/project/{uuid}/restore": {
      "parameters": [
        {
          "name": "client_uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a user",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Restore the project by ID.",
        "operationId": "postFlant_iamClientClient_uuidProjectUuidRestore",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/client/{uuid}": {
      "parameters": [
        {
          "name": "uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the client by ID.",
        "operationId": "getFlant_iamClientUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the client by ID.",
        "operationId": "postFlant_iamClientUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  }
                },
                "required": [
                  "identifier",
                  "resource_version"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the client by ID.",
        "operationId": "deleteFlant_iamClientUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/client/{uuid}/restore": {
      "parameters": [
        {
          "name": "uuid",
          "description": "ID of a client",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Restore the client by ID.",
        "operationId": "postFlant_iamClientUuidRestore",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "full_restore": {
                    "type": "boolean",
                    "description": "Option to restore full client data"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/configure_extension/flant_flow/flant_tenant/{flant_tenant_uuid}": {
      "parameters": [
        {
          "name": "flant_tenant_uuid",
          "description": "ID of a tenant which is Flant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Set Flant uuid",
        "operationId": "postFlant_iamConfigure_extensionFlant_flowFlant_tenantFlant_tenant_uuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/configure_extension/flant_flow/specific_roles": {
      "x-vault-createSupported": true,
      "post": {
        "summary": "Set specific iam.roles for flant_flow extension",
        "operationId": "postFlant_iamConfigure_extensionFlant_flowSpecific_roles",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "specific_roles": {
                    "type": "object",
                    "description": "Mapping some specific keys to iam.RoleName, mandatory keys:[]",
                    "format": "kvpairs"
                  }
                },
                "required": [
                  "specific_roles"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/configure_extension/flant_flow/specific_teams": {
      "x-vault-createSupported": true,
      "post": {
        "summary": "Set specific teams for flant_flow extension",
        "operationId": "postFlant_iamConfigure_extensionFlant_flowSpecific_teams",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "specific_teams": {
                    "type": "object",
                    "description": "Mapping some specific keys to flant_flow.TeamUUID, mandatory keys:[L1 mk8s Okmeter]",
                    "format": "kvpairs"
                  }
                },
                "required": [
                  "specific_teams"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/configure_extension/server_access": {
      "post": {
        "summary": "Register server",
        "operationId": "postFlant_iamConfigure_extensionServer_access",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "delete_expired_password_seeds_after": {
                    "type": "integer",
                    "description": "Duration after which expired password seed will be garbage collected",
                    "format": "seconds"
                  },
                  "expire_password_seed_after_reveal_in": {
                    "type": "integer",
                    "description": "Duration after password reveal after which password seeds will be expired",
                    "format": "seconds"
                  },
                  "last_allocated_uid": {
                    "type": "integer",
                    "description": "Last allocated POSIX UID"
                  },
                  "role_for_ssh_access": {
                    "type": "string",
                    "description": "Role to use for SSH access"
                  },
                  "roles_for_servers": {
                    "type": "array",
                    "description": "List of roles assigned to newly created server Groups",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "roles_for_servers",
                  "role_for_ssh_access",
                  "delete_expired_password_seeds_after",
                  "expire_password_seed_after_reveal_in"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/feature_flag": {
      "get": {
        "summary": "Lists all feature flags.",
        "operationId": "getFlant_iamFeature_flag",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/feature_flag/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "Feature flag name",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "delete": {
        "summary": "Deletes the featureFlag by ID.",
        "operationId": "deleteFlant_iamFeature_flagName",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/jwks": {
      "description": "Endpoint to expose public keys to check authority of issued tokens.",
      "get": {
        "summary": "Endpoint to expose public keys to check authority of issued tokens.",
        "operationId": "getFlant_iamJwks",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/jwt/configure": {
      "description": "Configure JWT options.",
      "get": {
        "summary": "Read JWT issuing status and configuration.",
        "operationId": "getFlant_iamJwtConfigure",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure JWT options.",
        "operationId": "postFlant_iamJwtConfigure",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. The issuer is a case sensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components, but no query or fragment components.",
                    "default": "https://auth.negentropy.flant.com/"
                  },
                  "multipass_audience": {
                    "type": "string",
                    "description": "Value of the audience claim.",
                    "default": "limbo"
                  },
                  "preliminary_announce_period": {
                    "type": "integer",
                    "description": "Publish the key in advance after specified amount of time.",
                    "format": "seconds",
                    "default": "1d"
                  },
                  "rotation_period": {
                    "type": "integer",
                    "description": "Force rotate public/private key pair.",
                    "format": "seconds",
                    "default": "1d"
                  }
                },
                "required": [
                  "issuer",
                  "multipass_audience",
                  "rotation_period",
                  "preliminary_announce_period"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/jwt/disable": {
      "description": "Disable JWT issuing.",
      "post": {
        "summary": "Disable JWT issuing.",
        "operationId": "postFlant_iamJwtDisable",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/jwt/enable": {
      "description": "Enable JWT issuing.",
      "post": {
        "summary": "Enable JWT issuing.",
        "operationId": "postFlant_iamJwtEnable",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/jwt/rotate_key": {
      "description": "Force key rotation. Calling this endpoint will rotate keys immediately.",
      "post": {
        "summary": "Force key rotation. Calling this endpoint will rotate keys immediately.",
        "operationId": "postFlant_iamJwtRotate_key",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/kafka/configure": {
      "x-vault-createSupported": true,
      "post": {
        "summary": "Setup kafka plugin configuration",
        "operationId": "postFlant_iamKafkaConfigure",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "peers_public_keys": {
                    "type": "array",
                    "description": "Vault public keys to check signature in JWKS topic",
                    "items": {
                      "type": "string"
                    }
                  },
                  "self_topic_name": {
                    "type": "string",
                    "description": "Kafka topic name for this plugin entities"
                  }
                },
                "required": [
                  "self_topic_name"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/kafka/configure_access": {
      "post": {
        "summary": "Setup kafka configuration",
        "operationId": "postFlant_iamKafkaConfigure_access",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "certificate": {
                    "type": "string",
                    "description": "x509 certificate to establish Kafka TLS connection"
                  },
                  "kafka_endpoints": {
                    "type": "array",
                    "description": "List of kafka backends. Ex: 192.168.1.1:9093",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "kafka_endpoints"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/kafka/generate_csr": {
      "parameters": [
        {
          "name": "force",
          "description": "Enforce private key recreation",
          "in": "query",
          "schema": {
            "type": "boolean",
            "default": false
          }
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Generate CSR for kafka endpoint",
        "operationId": "postFlant_iamKafkaGenerate_csr",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/kafka/public_key": {
      "get": {
        "summary": "Return public key",
        "operationId": "getFlant_iamKafkaPublic_key",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/replica": {
      "get": {
        "summary": "Lists all flant_iam replication backends",
        "operationId": "getFlant_iamReplica",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/replica/{replica_name}": {
      "parameters": [
        {
          "name": "replica_name",
          "description": "replication name",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "getFlant_iamReplicaReplica_name",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "postFlant_iamReplicaReplica_name",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "public_key": {
                    "type": "string",
                    "description": "Public rsa key for encryption"
                  },
                  "type": {
                    "type": "string",
                    "description": "replication type",
                    "enum": [
                      "Vault",
                      "Metadata"
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "deleteFlant_iamReplicaReplica_name",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/role": {
      "get": {
        "summary": "Lists all roles IDs",
        "operationId": "getFlant_iamRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/role/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "Role name, unique globally",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the role by ID",
        "operationId": "getFlant_iamRoleName",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the role by ID",
        "operationId": "postFlant_iamRoleName",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "type": "string",
                    "description": "Role description"
                  },
                  "options_schema": {
                    "type": "string",
                    "description": "JSON schema of the role options"
                  },
                  "require_one_of_feature_flags": {
                    "type": "array",
                    "description": "Enumerated flags, one of which is required in the scope to use role",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "description",
                  "require_one_of_feature_flags",
                  "options_schema"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the role by ID",
        "operationId": "deleteFlant_iamRoleName",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/role/{name}/include/{included_name}": {
      "parameters": [
        {
          "name": "included_name",
          "description": "Role name to include",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "name",
          "description": "Destination role name",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Include role",
        "operationId": "postFlant_iamRoleNameIncludeIncluded_name",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "options_template": {
                    "type": "string",
                    "description": "Go template to use outermost values in the included role schema"
                  }
                },
                "required": [
                  "options_template"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Exclude role",
        "operationId": "deleteFlant_iamRoleNameIncludeIncluded_name",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/team": {
      "get": {
        "summary": "Lists all teams IDs.",
        "operationId": "getFlant_iamTeam",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/team/privileged": {
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create team with preexistent ID.",
        "operationId": "postFlant_iamTeamPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for team",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "parent_team_uuid": {
                    "type": "string",
                    "description": "ID of parent team"
                  },
                  "team_type": {
                    "type": "string",
                    "description": "Type of team",
                    "pattern": "\\w([\\w-.]*\\w)?",
                    "enum": [
                      "standard_team",
                      "devops_team"
                    ]
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a team",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "team_type",
                  "uuid",
                  "identifier"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/team/{team_uuid}/teammate": {
      "parameters": [
        {
          "name": "team_uuid",
          "description": "ID of a team",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all teammates IDs.",
        "operationId": "getFlant_iamTeamTeam_uuidTeammate",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/team/{team_uuid}/teammate/privileged": {
      "parameters": [
        {
          "name": "team_uuid",
          "description": "ID of a team",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create teammate with preexistent ID.",
        "operationId": "postFlant_iamTeamTeam_uuidTeammatePrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "additional_emails": {
                    "type": "array",
                    "description": "additional_emails",
                    "items": {
                      "type": "string"
                    }
                  },
                  "additional_phones": {
                    "type": "array",
                    "description": "additional_phones",
                    "items": {
                      "type": "string"
                    }
                  },
                  "display_name": {
                    "type": "string",
                    "description": "display_name"
                  },
                  "email": {
                    "type": "string",
                    "description": "email"
                  },
                  "first_name": {
                    "type": "string",
                    "description": "first_name"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "last_name": {
                    "type": "string",
                    "description": "last_name"
                  },
                  "mobile_phone": {
                    "type": "string",
                    "description": "mobile_phone"
                  },
                  "role_at_team": {
                    "type": "string",
                    "description": "role at team",
                    "enum": [
                      "member",
                      "engineer",
                      "manager",
                      "project_manager",
                      "teamlead"
                    ]
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a teammate",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "role_at_team",
                  "identifier",
                  "last_name",
                  "mobile_phone",
                  "additional_phones",
                  "additional_emails",
                  "uuid",
                  "first_name",
                  "display_name",
                  "email"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/team/{team_uuid}/teammate/{uuid}": {
      "parameters": [
        {
          "name": "team_uuid",
          "description": "ID of a team",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a teammate",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the teammate by ID",
        "operationId": "getFlant_iamTeamTeam_uuidTeammateUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the teammate by ID",
        "operationId": "postFlant_iamTeamTeam_uuidTeammateUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "additional_emails": {
                    "type": "array",
                    "description": "additional_emails",
                    "items": {
                      "type": "string"
                    }
                  },
                  "additional_phones": {
                    "type": "array",
                    "description": "additional_phones",
                    "items": {
                      "type": "string"
                    }
                  },
                  "display_name": {
                    "type": "string",
                    "description": "display_name"
                  },
                  "email": {
                    "type": "string",
                    "description": "email"
                  },
                  "first_name": {
                    "type": "string",
                    "description": "first_name"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "last_name": {
                    "type": "string",
                    "description": "last_name"
                  },
                  "mobile_phone": {
                    "type": "string",
                    "description": "mobile_phone"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  },
                  "role_at_team": {
                    "type": "string",
                    "description": "role at team",
                    "enum": [
                      "member",
                      "engineer",
                      "manager",
                      "project_manager",
                      "teamlead"
                    ]
                  }
                },
                "required": [
                  "display_name",
                  "mobile_phone",
                  "role_at_team",
                  "resource_version",
                  "first_name",
                  "email",
                  "additional_phones",
                  "identifier",
                  "last_name",
                  "additional_emails"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the teammate by ID",
        "operationId": "deleteFlant_iamTeamTeam_uuidTeammateUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/team/{team_uuid}/teammate/{uuid}/restore": {
      "parameters": [
        {
          "name": "team_uuid",
          "description": "ID of a team",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a teammate",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Restore the teammate by ID.",
        "operationId": "postFlant_iamTeamTeam_uuidTeammateUuidRestore",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/team/{uuid}": {
      "parameters": [
        {
          "name": "uuid",
          "description": "ID of a team",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the team by ID.",
        "operationId": "getFlant_iamTeamUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the team by ID.",
        "operationId": "postFlant_iamTeamUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier team",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "parent_team_uuid": {
                    "type": "string",
                    "description": "ID of parent team"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  }
                },
                "required": [
                  "resource_version"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the team by ID.",
        "operationId": "deleteFlant_iamTeamUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/team/{uuid}/restore": {
      "parameters": [
        {
          "name": "uuid",
          "description": "ID of a team",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Restore the team by ID.",
        "operationId": "postFlant_iamTeamUuidRestore",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "full_restore": {
                    "type": "boolean",
                    "description": "Option to restore full team data"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant": {
      "get": {
        "summary": "Lists all tenants IDs.",
        "operationId": "getFlant_iamTenant",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/privileged": {
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create tenant with preexistent ID.",
        "operationId": "postFlant_iamTenantPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a tenant",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "uuid",
                  "identifier"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/feature_flag/{feature_flag_name}": {
      "parameters": [
        {
          "name": "feature_flag_name",
          "description": "Feature flag's name",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Add Feature flag to the tenant.",
        "operationId": "postFlant_iamTenantTenant_uuidFeature_flagFeature_flag_name",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "enabled_for_new_projects": {
                    "type": "boolean",
                    "description": "Enable by default for a new projects inside this tenant",
                    "default": true
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove Feature flag from the tenant.",
        "operationId": "deleteFlant_iamTenantTenant_uuidFeature_flagFeature_flag_name",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/group": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all groups IDs.",
        "operationId": "getFlant_iamTenantTenant_uuidGroup",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/group/privileged": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create group with preexistent ID.",
        "operationId": "postFlant_iamTenantTenant_uuidGroupPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines"
                  },
                  "members": {
                    "type": "array",
                    "description": "Members list",
                    "items": {
                      "type": "object"
                    }
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a group",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "uuid",
                  "identifier",
                  "members"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/group/{uuid}": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a group",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the service account by ID.",
        "operationId": "getFlant_iamTenantTenant_uuidGroupUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the service account by ID.",
        "operationId": "postFlant_iamTenantTenant_uuidGroupUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines"
                  },
                  "members": {
                    "type": "array",
                    "description": "Members list",
                    "items": {
                      "type": "object"
                    }
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  }
                },
                "required": [
                  "resource_version",
                  "identifier",
                  "members"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the service account by ID.",
        "operationId": "deleteFlant_iamTenantTenant_uuidGroupUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/identity_sharing": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all tenant identity sharing IDs.",
        "operationId": "getFlant_iamTenantTenant_uuidIdentity_sharing",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/identity_sharing/privileged": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create identity sharing.",
        "operationId": "postFlant_iamTenantTenant_uuidIdentity_sharingPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "destination_tenant_uuid": {
                    "type": "string",
                    "description": "ID of a destination tenant",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "groups": {
                    "type": "array",
                    "description": "ID of sharing groups",
                    "items": {
                      "type": "string"
                    }
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a tenant",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "destination_tenant_uuid",
                  "uuid"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/identity_sharing/{uuid}": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of an identity sharing",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the identity sharing by ID",
        "operationId": "getFlant_iamTenantTenant_uuidIdentity_sharingUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the identity sharing by ID",
        "operationId": "deleteFlant_iamTenantTenant_uuidIdentity_sharingUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all projects IDs.",
        "operationId": "getFlant_iamTenantTenant_uuidProject",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project/privileged": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create project with preexistent ID.",
        "operationId": "postFlant_iamTenantTenant_uuidProjectPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a project",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "uuid",
                  "identifier"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project/{project_uuid}/feature_flag/{feature_flag_name}": {
      "parameters": [
        {
          "name": "feature_flag_name",
          "description": "Feature flag's name",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "project_uuid",
          "description": "ID of a project",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Add FeatureFlag to the project.",
        "operationId": "postFlant_iamTenantTenant_uuidProjectProject_uuidFeature_flagFeature_flag_name",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove FeatureFlag from the project.",
        "operationId": "deleteFlant_iamTenantTenant_uuidProjectProject_uuidFeature_flagFeature_flag_name",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project/{project_uuid}/register_server": {
      "parameters": [
        {
          "name": "project_uuid",
          "description": "ID of a project",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Register server",
        "operationId": "postFlant_iamTenantTenant_uuidProjectProject_uuidRegister_server",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "annotations": {
                    "type": "object",
                    "description": "Map of annotations",
                    "format": "map"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "labels": {
                    "type": "object",
                    "description": "Map of labels",
                    "format": "map"
                  }
                },
                "required": [
                  "identifier"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project/{project_uuid}/server/{server_uuid}": {
      "parameters": [
        {
          "name": "project_uuid",
          "description": "ID of a project",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "server_uuid",
          "description": "ID of a server",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read a server",
        "operationId": "getFlant_iamTenantTenant_uuidProjectProject_uuidServerServer_uuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update a server",
        "operationId": "postFlant_iamTenantTenant_uuidProjectProject_uuidServerServer_uuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "annotations": {
                    "type": "object",
                    "description": "Map of annotations",
                    "format": "map"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "labels": {
                    "type": "object",
                    "description": "Map of labels",
                    "format": "map"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a server",
        "operationId": "deleteFlant_iamTenantTenant_uuidProjectProject_uuidServerServer_uuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project/{project_uuid}/server/{server_uuid}/connection_info": {
      "parameters": [
        {
          "name": "server_uuid",
          "description": "ID of a server",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Update a server's connection_info",
        "operationId": "postFlant_iamTenantTenant_uuidProjectProject_uuidServerServer_uuidConnection_info",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "hostname": {
                    "type": "string",
                    "description": "IP or a hostname"
                  },
                  "jump_hostname": {
                    "type": "string",
                    "description": "IP or a hostname, optional"
                  },
                  "jump_port": {
                    "type": "string",
                    "description": "Port, optional, 22 by default if jump_hostname is defined"
                  },
                  "port": {
                    "type": "string",
                    "description": "Port, optional, 22 by default"
                  }
                },
                "required": [
                  "hostname"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project/{project_uuid}/server/{server_uuid}/fingerprint": {
      "parameters": [
        {
          "name": "server_uuid",
          "description": "ID of a server",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read a server's fingerprint",
        "operationId": "getFlant_iamTenantTenant_uuidProjectProject_uuidServerServer_uuidFingerprint",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update a server's fingerprint",
        "operationId": "postFlant_iamTenantTenant_uuidProjectProject_uuidServerServer_uuidFingerprint",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "fingerprint": {
                    "type": "string",
                    "description": "Fingerprint of a server",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project/{project_uuid}/servers": {
      "parameters": [
        {
          "name": "project_uuid",
          "description": "ID of a project",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "List servers",
        "operationId": "getFlant_iamTenantTenant_uuidProjectProject_uuidServers",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project/{uuid}": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a project",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the project by ID.",
        "operationId": "getFlant_iamTenantTenant_uuidProjectUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the project by ID.",
        "operationId": "postFlant_iamTenantTenant_uuidProjectUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  }
                },
                "required": [
                  "resource_version",
                  "identifier"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the project by ID.",
        "operationId": "deleteFlant_iamTenantTenant_uuidProjectUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/project/{uuid}/restore": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a user",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Restore the project by ID.",
        "operationId": "postFlant_iamTenantTenant_uuidProjectUuidRestore",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/role_binding": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all roleBindings IDs.",
        "operationId": "getFlant_iamTenantTenant_uuidRole_binding",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/role_binding/privileged": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create roleBinding with preexistent ID.",
        "operationId": "postFlant_iamTenantTenant_uuidRole_bindingPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "any_project": {
                    "type": "boolean",
                    "description": "allow rolebinding for all projects of tenant"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "members": {
                    "type": "array",
                    "description": "Members list",
                    "items": {
                      "type": "object"
                    }
                  },
                  "require_mfa": {
                    "type": "boolean",
                    "description": "Requires multi-factor authentication"
                  },
                  "roles": {
                    "type": "array",
                    "description": "Roles list",
                    "items": {
                      "type": "object"
                    }
                  },
                  "ttl": {
                    "type": "integer",
                    "description": "TTL in seconds",
                    "format": "seconds"
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a roleBinding",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "identifier",
                  "members",
                  "roles",
                  "ttl",
                  "require_mfa",
                  "any_project",
                  "uuid"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/role_binding/{role_binding_uuid}/approval": {
      "parameters": [
        {
          "name": "role_binding_uuid",
          "description": "ID of a roleBinding",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all approvals for role_binding",
        "operationId": "getFlant_iamTenantTenant_uuidRole_bindingRole_binding_uuidApproval",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/role_binding/{role_binding_uuid}/approval/{uuid}": {
      "parameters": [
        {
          "name": "role_binding_uuid",
          "description": "ID of a roleBinding",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a role binding approval",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the role binding approval by ID.",
        "operationId": "getFlant_iamTenantTenant_uuidRole_bindingRole_binding_uuidApprovalUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the role binding approval by ID.",
        "operationId": "postFlant_iamTenantTenant_uuidRole_bindingRole_binding_uuidApprovalUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "approvers": {
                    "type": "array",
                    "description": "Approvers list",
                    "items": {
                      "type": "object"
                    }
                  },
                  "require_mfa": {
                    "type": "boolean",
                    "description": "Necessity to approve second auth factor.",
                    "default": false
                  },
                  "require_unique_approver": {
                    "type": "boolean",
                    "description": "Whether the approver is required to be unique among all approvals.",
                    "default": true
                  },
                  "required_votes": {
                    "type": "integer",
                    "description": "Cound of required approves."
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  }
                },
                "required": [
                  "required_votes",
                  "resource_version",
                  "approvers"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the role binding approval by ID.",
        "operationId": "deleteFlant_iamTenantTenant_uuidRole_bindingRole_binding_uuidApprovalUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/role_binding/{uuid}": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a roleBinding",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the role binding by ID.",
        "operationId": "getFlant_iamTenantTenant_uuidRole_bindingUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the role binding by ID.",
        "operationId": "postFlant_iamTenantTenant_uuidRole_bindingUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "any_project": {
                    "type": "boolean",
                    "description": "allow rolebinding for all projects of tenant"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "members": {
                    "type": "array",
                    "description": "Members list",
                    "items": {
                      "type": "object"
                    }
                  },
                  "require_mfa": {
                    "type": "boolean",
                    "description": "Requires multi-factor authentication"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  },
                  "roles": {
                    "type": "array",
                    "description": "Roles list",
                    "items": {
                      "type": "object"
                    }
                  },
                  "ttl": {
                    "type": "integer",
                    "description": "TTL in seconds",
                    "format": "seconds"
                  }
                },
                "required": [
                  "any_project",
                  "ttl",
                  "require_mfa",
                  "resource_version",
                  "identifier",
                  "members",
                  "roles"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the role binding by ID.",
        "operationId": "deleteFlant_iamTenantTenant_uuidRole_bindingUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/service_account": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all serviceAccounts IDs.",
        "operationId": "getFlant_iamTenantTenant_uuidService_account",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/service_account/privileged": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create serviceAccount with preexistent ID.",
        "operationId": "postFlant_iamTenantTenant_uuidService_accountPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allowed_cidrs": {
                    "type": "array",
                    "description": "CIDRs",
                    "items": {
                      "type": "string"
                    }
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "token_max_ttl": {
                    "type": "integer",
                    "description": "Multipass TTL in seconds",
                    "format": "seconds"
                  },
                  "token_ttl": {
                    "type": "integer",
                    "description": "Multipass TTL in seconds",
                    "format": "seconds"
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a serviceAccount",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "allowed_cidrs",
                  "token_ttl",
                  "token_max_ttl",
                  "uuid",
                  "identifier"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/service_account/{owner_uuid}/multipass": {
      "parameters": [
        {
          "name": "owner_uuid",
          "description": "ID of the tenant service account",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "List multipass IDs",
        "operationId": "getFlant_iamTenantTenant_uuidService_accountOwner_uuidMultipass",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/service_account/{owner_uuid}/multipass/{uuid}": {
      "parameters": [
        {
          "name": "owner_uuid",
          "description": "ID of the tenant service account",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a multipass",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Get multipass by ID",
        "operationId": "getFlant_iamTenantTenant_uuidService_accountOwner_uuidMultipassUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete multipass by ID",
        "operationId": "deleteFlant_iamTenantTenant_uuidService_accountOwner_uuidMultipassUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/service_account/{owner_uuid}/password": {
      "parameters": [
        {
          "name": "owner_uuid",
          "description": "ID of the tenant service account",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "List password IDs",
        "operationId": "getFlant_iamTenantTenant_uuidService_accountOwner_uuidPassword",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/service_account/{owner_uuid}/password/{uuid}": {
      "parameters": [
        {
          "name": "owner_uuid",
          "description": "ID of the tenant service account",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a password",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Get password by ID",
        "operationId": "getFlant_iamTenantTenant_uuidService_accountOwner_uuidPasswordUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete password by ID",
        "operationId": "deleteFlant_iamTenantTenant_uuidService_accountOwner_uuidPasswordUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/service_account/{uuid}": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a serviceAccount",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the service account by ID.",
        "operationId": "getFlant_iamTenantTenant_uuidService_accountUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the service account by ID.",
        "operationId": "postFlant_iamTenantTenant_uuidService_accountUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allowed_cidrs": {
                    "type": "array",
                    "description": "CIDRs",
                    "items": {
                      "type": "string"
                    }
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  },
                  "token_max_ttl": {
                    "type": "integer",
                    "description": "Multipass TTL in seconds",
                    "format": "seconds"
                  },
                  "token_ttl": {
                    "type": "integer",
                    "description": "Multipass TTL in seconds",
                    "format": "seconds"
                  }
                },
                "required": [
                  "resource_version",
                  "identifier",
                  "allowed_cidrs",
                  "token_ttl",
                  "token_max_ttl"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the service account by ID.",
        "operationId": "deleteFlant_iamTenantTenant_uuidService_accountUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/user": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Lists all users IDs.",
        "operationId": "getFlant_iamTenantTenant_uuidUser",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/user/privileged": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Create user with preexistent ID.",
        "operationId": "postFlant_iamTenantTenant_uuidUserPrivileged",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "additional_emails": {
                    "type": "array",
                    "description": "additional_emails",
                    "items": {
                      "type": "string"
                    }
                  },
                  "additional_phones": {
                    "type": "array",
                    "description": "additional_phones",
                    "items": {
                      "type": "string"
                    }
                  },
                  "display_name": {
                    "type": "string",
                    "description": "display_name"
                  },
                  "email": {
                    "type": "string",
                    "description": "email"
                  },
                  "first_name": {
                    "type": "string",
                    "description": "first_name"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "last_name": {
                    "type": "string",
                    "description": "last_name"
                  },
                  "mobile_phone": {
                    "type": "string",
                    "description": "mobile_phone"
                  },
                  "uuid": {
                    "type": "string",
                    "description": "ID of a user",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  }
                },
                "required": [
                  "first_name",
                  "mobile_phone",
                  "identifier",
                  "uuid",
                  "last_name",
                  "email",
                  "additional_phones",
                  "display_name",
                  "additional_emails"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/user/{owner_uuid}/multipass": {
      "parameters": [
        {
          "name": "owner_uuid",
          "description": "ID of the tenant user",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "List multipass IDs",
        "operationId": "getFlant_iamTenantTenant_uuidUserOwner_uuidMultipass",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/user/{owner_uuid}/multipass/{uuid}": {
      "parameters": [
        {
          "name": "owner_uuid",
          "description": "ID of the tenant user",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a multipass",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Get multipass by ID",
        "operationId": "getFlant_iamTenantTenant_uuidUserOwner_uuidMultipassUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete multipass by ID",
        "operationId": "deleteFlant_iamTenantTenant_uuidUserOwner_uuidMultipassUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/user/{uuid}": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a user",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the user by ID",
        "operationId": "getFlant_iamTenantTenant_uuidUserUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the user by ID",
        "operationId": "postFlant_iamTenantTenant_uuidUserUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "additional_emails": {
                    "type": "array",
                    "description": "additional_emails",
                    "items": {
                      "type": "string"
                    }
                  },
                  "additional_phones": {
                    "type": "array",
                    "description": "additional_phones",
                    "items": {
                      "type": "string"
                    }
                  },
                  "display_name": {
                    "type": "string",
                    "description": "display_name"
                  },
                  "email": {
                    "type": "string",
                    "description": "email"
                  },
                  "first_name": {
                    "type": "string",
                    "description": "first_name"
                  },
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "last_name": {
                    "type": "string",
                    "description": "last_name"
                  },
                  "mobile_phone": {
                    "type": "string",
                    "description": "mobile_phone"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  }
                },
                "required": [
                  "first_name",
                  "mobile_phone",
                  "identifier",
                  "display_name",
                  "last_name",
                  "additional_phones",
                  "email",
                  "additional_emails",
                  "resource_version"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the user by ID",
        "operationId": "deleteFlant_iamTenantTenant_uuidUserUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{tenant_uuid}/user/{uuid}/restore": {
      "parameters": [
        {
          "name": "tenant_uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        },
        {
          "name": "uuid",
          "description": "ID of a user",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Restore the user by ID.",
        "operationId": "postFlant_iamTenantTenant_uuidUserUuidRestore",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{uuid}": {
      "parameters": [
        {
          "name": "uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the tenant by ID.",
        "operationId": "getFlant_iamTenantUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the tenant by ID.",
        "operationId": "postFlant_iamTenantUuid",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "description": "Identifier for humans and machines",
                    "pattern": "\\w([\\w-.]*\\w)?"
                  },
                  "resource_version": {
                    "type": "string",
                    "description": "Resource version"
                  }
                },
                "required": [
                  "identifier",
                  "resource_version"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the tenant by ID.",
        "operationId": "deleteFlant_iamTenantUuid",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/flant_iam/tenant/{uuid}/available_roles": {
      "parameters": [
        {
          "name": "uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the tenant roles.",
        "operationId": "getFlant_iamTenantUuidAvailable_roles",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/flant_iam/tenant/{uuid}/restore": {
      "parameters": [
        {
          "name": "uuid",
          "description": "ID of a tenant",
          "in": "path",
          "schema": {
            "type": "string",
            "pattern": "\\w([\\w-.]*\\w)?"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Restore the tenant by ID.",
        "operationId": "postFlant_iamTenantUuidRestore",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "full_restore": {
                    "type": "boolean",
                    "description": "Option to restore full tenant data"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/alias": {
      "description": "Create a new alias.",
      "post": {
        "summary": "Create a new alias.",
        "operationId": "postIdentityAlias",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "canonical_id": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to"
                  },
                  "entity_id": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to. This field is deprecated in favor of 'canonical_id'."
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the alias"
                  },
                  "mount_accessor": {
                    "type": "string",
                    "description": "Mount accessor to which this alias belongs to"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the alias"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/alias/id": {
      "description": "List all the alias IDs.",
      "get": {
        "summary": "List all the alias IDs.",
        "operationId": "getIdentityAliasId",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/alias/id/{id}": {
      "description": "Update, read or delete an alias ID.",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the alias",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "getIdentityAliasIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "postIdentityAliasIdId",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "canonical_id": {
                    "type": "string",
                    "description": "Entity ID to which this alias should be tied to"
                  },
                  "entity_id": {
                    "type": "string",
                    "description": "Entity ID to which this alias should be tied to. This field is deprecated in favor of 'canonical_id'."
                  },
                  "mount_accessor": {
                    "type": "string",
                    "description": "Mount accessor to which this alias belongs to"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the alias"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "deleteIdentityAliasIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/entity": {
      "description": "Create a new entity",
      "post": {
        "summary": "Create a new entity",
        "operationId": "postIdentityEntity",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "disabled": {
                    "type": "boolean",
                    "description": "If set true, tokens tied to this identity will not be able to be used (but will not be revoked)."
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the entity. If set, updates the corresponding existing entity."
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
                    "format": "kvpairs"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the entity"
                  },
                  "policies": {
                    "type": "array",
                    "description": "Policies to be tied to the entity.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity-alias": {
      "description": "Create a new alias.",
      "post": {
        "summary": "Create a new alias.",
        "operationId": "postIdentityEntityAlias",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "canonical_id": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs"
                  },
                  "entity_id": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs. This field is deprecated, use canonical_id."
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the entity alias. If set, updates the corresponding entity alias."
                  },
                  "mount_accessor": {
                    "type": "string",
                    "description": "Mount accessor to which this alias belongs to; unused for a modify"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the alias; unused for a modify"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity-alias/id": {
      "description": "List all the alias IDs.",
      "get": {
        "summary": "List all the alias IDs.",
        "operationId": "getIdentityEntityAliasId",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity-alias/id/{id}": {
      "description": "Update, read or delete an alias ID.",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the alias",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "getIdentityEntityAliasIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "postIdentityEntityAliasIdId",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "canonical_id": {
                    "type": "string",
                    "description": "Entity ID to which this alias should be tied to"
                  },
                  "entity_id": {
                    "type": "string",
                    "description": "Entity ID to which this alias belongs to. This field is deprecated, use canonical_id."
                  },
                  "mount_accessor": {
                    "type": "string",
                    "description": "(Unused)"
                  },
                  "name": {
                    "type": "string",
                    "description": "(Unused)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "deleteIdentityEntityAliasIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/entity/batch-delete": {
      "description": "Delete all of the entities provided",
      "post": {
        "summary": "Delete all of the entities provided",
        "operationId": "postIdentityEntityBatchDelete",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "entity_ids": {
                    "type": "array",
                    "description": "Entity IDs to delete",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity/id": {
      "description": "List all the entity IDs",
      "get": {
        "summary": "List all the entity IDs",
        "operationId": "getIdentityEntityId",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity/id/{id}": {
      "description": "Update, read or delete an entity using entity ID",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the entity. If set, updates the corresponding existing entity.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an entity using entity ID",
        "operationId": "getIdentityEntityIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an entity using entity ID",
        "operationId": "postIdentityEntityIdId",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "disabled": {
                    "type": "boolean",
                    "description": "If set true, tokens tied to this identity will not be able to be used (but will not be revoked)."
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
                    "format": "kvpairs"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the entity"
                  },
                  "policies": {
                    "type": "array",
                    "description": "Policies to be tied to the entity.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an entity using entity ID",
        "operationId": "deleteIdentityEntityIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/entity/merge": {
      "description": "Merge two or more entities together",
      "post": {
        "summary": "Merge two or more entities together",
        "operationId": "postIdentityEntityMerge",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "force": {
                    "type": "boolean",
                    "description": "Setting this will follow the 'mine' strategy for merging MFA secrets. If there are secrets of the same type both in entities that are merged from and in entity into which all others are getting merged, secrets in the destination will be unaltered. If not set, this API will throw an error containing all the conflicts."
                  },
                  "from_entity_ids": {
                    "type": "array",
                    "description": "Entity IDs which needs to get merged",
                    "items": {
                      "type": "string"
                    }
                  },
                  "to_entity_id": {
                    "type": "string",
                    "description": "Entity ID into which all the other entities need to get merged"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity/name": {
      "description": "List all the entity names",
      "get": {
        "summary": "List all the entity names",
        "operationId": "getIdentityEntityName",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity/name/{name}": {
      "description": "Update, read or delete an entity using entity name",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the entity",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an entity using entity name",
        "operationId": "getIdentityEntityNameName",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an entity using entity name",
        "operationId": "postIdentityEntityNameName",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "disabled": {
                    "type": "boolean",
                    "description": "If set true, tokens tied to this identity will not be able to be used (but will not be revoked)."
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the entity. If set, updates the corresponding existing entity."
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
                    "format": "kvpairs"
                  },
                  "policies": {
                    "type": "array",
                    "description": "Policies to be tied to the entity.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an entity using entity name",
        "operationId": "deleteIdentityEntityNameName",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/group": {
      "description": "Create a new group.",
      "post": {
        "summary": "Create a new group.",
        "operationId": "postIdentityGroup",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "ID of the group. If set, updates the corresponding existing group."
                  },
                  "member_entity_ids": {
                    "type": "array",
                    "description": "Entity IDs to be assigned as group members.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "member_group_ids": {
                    "type": "array",
                    "description": "Group IDs to be assigned as group members.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
                    "format": "kvpairs"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the group."
                  },
                  "policies": {
                    "type": "array",
                    "description": "Policies to be tied to the group.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "type": {
                    "type": "string",
                    "description": "Type of the group, 'internal' or 'external'. Defaults to 'internal'"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group-alias": {
      "description": "Creates a new group alias, or updates an existing one.",
      "post": {
        "summary": "Creates a new group alias, or updates an existing one.",
        "operationId": "postIdentityGroupAlias",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "canonical_id": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias."
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the group alias."
                  },
                  "mount_accessor": {
                    "type": "string",
                    "description": "Mount accessor to which this alias belongs to."
                  },
                  "name": {
                    "type": "string",
                    "description": "Alias of the group."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group-alias/id": {
      "description": "List all the group alias IDs.",
      "get": {
        "summary": "List all the group alias IDs.",
        "operationId": "getIdentityGroupAliasId",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group-alias/id/{id}": {
      "parameters": [
        {
          "name": "id",
          "description": "ID of the group alias.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "getIdentityGroupAliasIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "postIdentityGroupAliasIdId",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "canonical_id": {
                    "type": "string",
                    "description": "ID of the group to which this is an alias."
                  },
                  "mount_accessor": {
                    "type": "string",
                    "description": "Mount accessor to which this alias belongs to."
                  },
                  "name": {
                    "type": "string",
                    "description": "Alias of the group."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "deleteIdentityGroupAliasIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/group/id": {
      "description": "List all the group IDs.",
      "get": {
        "summary": "List all the group IDs.",
        "operationId": "getIdentityGroupId",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group/id/{id}": {
      "description": "Update or delete an existing group using its ID.",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the group. If set, updates the corresponding existing group.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update or delete an existing group using its ID.",
        "operationId": "getIdentityGroupIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update or delete an existing group using its ID.",
        "operationId": "postIdentityGroupIdId",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "member_entity_ids": {
                    "type": "array",
                    "description": "Entity IDs to be assigned as group members.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "member_group_ids": {
                    "type": "array",
                    "description": "Group IDs to be assigned as group members.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
                    "format": "kvpairs"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the group."
                  },
                  "policies": {
                    "type": "array",
                    "description": "Policies to be tied to the group.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "type": {
                    "type": "string",
                    "description": "Type of the group, 'internal' or 'external'. Defaults to 'internal'"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update or delete an existing group using its ID.",
        "operationId": "deleteIdentityGroupIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/group/name": {
      "get": {
        "operationId": "getIdentityGroupName",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group/name/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "Name of the group.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "getIdentityGroupNameName",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "postIdentityGroupNameName",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "ID of the group. If set, updates the corresponding existing group."
                  },
                  "member_entity_ids": {
                    "type": "array",
                    "description": "Entity IDs to be assigned as group members.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "member_group_ids": {
                    "type": "array",
                    "description": "Group IDs to be assigned as group members.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
                    "format": "kvpairs"
                  },
                  "policies": {
                    "type": "array",
                    "description": "Policies to be tied to the group.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "type": {
                    "type": "string",
                    "description": "Type of the group, 'internal' or 'external'. Defaults to 'internal'"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "deleteIdentityGroupNameName",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/lookup/entity": {
      "description": "Query entities based on various properties.",
      "post": {
        "summary": "Query entities based on various properties.",
        "operationId": "postIdentityLookupEntity",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "alias_id": {
                    "type": "string",
                    "description": "ID of the alias."
                  },
                  "alias_mount_accessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'."
                  },
                  "alias_name": {
                    "type": "string",
                    "description": "Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'."
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the entity."
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the entity."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/lookup/group": {
      "description": "Query groups based on various properties.",
      "post": {
        "summary": "Query groups based on various properties.",
        "operationId": "postIdentityLookupGroup",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "alias_id": {
                    "type": "string",
                    "description": "ID of the alias."
                  },
                  "alias_mount_accessor": {
                    "type": "string",
                    "description": "Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'."
                  },
                  "alias_name": {
                    "type": "string",
                    "description": "Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'."
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the group."
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the group."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/.well-known/keys": {
      "description": "Retrieve public keys",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Retrieve public keys",
        "operationId": "getIdentityOidcWellKnownKeys",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/.well-known/openid-configuration": {
      "description": "Query OIDC configurations",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Query OIDC configurations",
        "operationId": "getIdentityOidcWellKnownOpenidConfiguration",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/config": {
      "description": "OIDC configuration",
      "get": {
        "summary": "OIDC configuration",
        "operationId": "getIdentityOidcConfig",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "OIDC configuration",
        "operationId": "postIdentityOidcConfig",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "issuer": {
                    "type": "string",
                    "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's app_addr will be used."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/introspect": {
      "description": "Verify the authenticity of an OIDC token",
      "post": {
        "summary": "Verify the authenticity of an OIDC token",
        "operationId": "postIdentityOidcIntrospect",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "client_id": {
                    "type": "string",
                    "description": "Optional client_id to verify"
                  },
                  "token": {
                    "type": "string",
                    "description": "Token to verify"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/key": {
      "description": "List OIDC keys",
      "get": {
        "summary": "List OIDC keys",
        "operationId": "getIdentityOidcKey",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/key/{name}": {
      "description": "CRUD operations for OIDC keys.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "CRUD operations for OIDC keys.",
        "operationId": "getIdentityOidcKeyName",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "CRUD operations for OIDC keys.",
        "operationId": "postIdentityOidcKeyName",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "algorithm": {
                    "type": "string",
                    "description": "Signing algorithm to use. This will default to RS256.",
                    "default": "RS256"
                  },
                  "allowed_client_ids": {
                    "type": "array",
                    "description": "Comma separated string or array of role client ids allowed to use this key for signing. If empty no roles are allowed. If \"*\" all roles are allowed.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "rotation_period": {
                    "type": "integer",
                    "description": "How often to generate a new keypair.",
                    "format": "seconds",
                    "default": "24h"
                  },
                  "verification_ttl": {
                    "type": "integer",
                    "description": "Controls how long the public portion of a key will be available for verification after being rotated.",
                    "format": "seconds",
                    "default": "24h"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "CRUD operations for OIDC keys.",
        "operationId": "deleteIdentityOidcKeyName",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/oidc/key/{name}/rotate": {
      "description": "Rotate a named OIDC key.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Rotate a named OIDC key.",
        "operationId": "postIdentityOidcKeyNameRotate",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "verification_ttl": {
                    "type": "integer",
                    "description": "Controls how long the public portion of a key will be available for verification after being rotated. Setting verification_ttl here will override the verification_ttl set on the key.",
                    "format": "seconds"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/role": {
      "description": "List configured OIDC roles",
      "get": {
        "summary": "List configured OIDC roles",
        "operationId": "getIdentityOidcRole",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/role/{name}": {
      "description": "CRUD operations on OIDC Roles",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "CRUD operations on OIDC Roles",
        "operationId": "getIdentityOidcRoleName",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "CRUD operations on OIDC Roles",
        "operationId": "postIdentityOidcRoleName",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "client_id": {
                    "type": "string",
                    "description": "Optional client_id"
                  },
                  "key": {
                    "type": "string",
                    "description": "The OIDC key to use for generating tokens. The specified key must already exist."
                  },
                  "template": {
                    "type": "string",
                    "description": "The template string to use for generating tokens. This may be in string-ified JSON or base64 format."
                  },
                  "ttl": {
                    "type": "integer",
                    "description": "TTL of the tokens generated against the role.",
                    "format": "seconds",
                    "default": "24h"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "CRUD operations on OIDC Roles",
        "operationId": "deleteIdentityOidcRoleName",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/oidc/token/{name}": {
      "description": "Generate an OIDC token",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Generate an OIDC token",
        "operationId": "getIdentityOidcTokenName",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/persona": {
      "description": "Create a new alias.",
      "post": {
        "summary": "Create a new alias.",
        "operationId": "postIdentityPersona",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "entity_id": {
                    "type": "string",
                    "description": "Entity ID to which this persona belongs to"
                  },
                  "id": {
                    "type": "string",
                    "description": "ID of the persona"
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
                    "format": "kvpairs"
                  },
                  "mount_accessor": {
                    "type": "string",
                    "description": "Mount accessor to which this persona belongs to"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the persona"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/persona/id": {
      "description": "List all the alias IDs.",
      "get": {
        "summary": "List all the alias IDs.",
        "operationId": "getIdentityPersonaId",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/persona/id/{id}": {
      "description": "Update, read or delete an alias ID.",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the persona",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "getIdentityPersonaIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "postIdentityPersonaIdId",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "entity_id": {
                    "type": "string",
                    "description": "Entity ID to which this persona should be tied to"
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
                    "format": "kvpairs"
                  },
                  "mount_accessor": {
                    "type": "string",
                    "description": "Mount accessor to which this persona belongs to"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the persona"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "deleteIdentityPersonaIdId",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/secret/.*": {},
    "/secret/config": {
      "description": "Configures settings for the KV store",
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read the backend level settings.",
        "operationId": "getSecretConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure backend level settings that are applied to every key in the key-value store.",
        "operationId": "postSecretConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "cas_required": {
                    "type": "boolean",
                    "description": "If true, the backend will require the cas parameter to be set for each write"
                  },
                  "delete_version_after": {
                    "type": "integer",
                    "description": "If set, the length of time before a version is deleted. A negative duration disables the use of delete_version_after on all keys. A zero duration clears the current setting. Accepts a Go duration format string.",
                    "format": "seconds"
                  },
                  "max_versions": {
                    "type": "integer",
                    "description": "The number of versions to keep for each key. Defaults to 10"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/secret/data/{path}": {
      "description": "Write, Read, and Delete data in the Key-Value Store.",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Write, Read, and Delete data in the Key-Value Store.",
        "operationId": "getSecretDataPath",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Write, Read, and Delete data in the Key-Value Store.",
        "operationId": "postSecretDataPath",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "data": {
                    "type": "object",
                    "description": "The contents of the data map will be stored and returned on read.",
                    "format": "map"
                  },
                  "options": {
                    "type": "object",
                    "description": "Options for writing a KV entry. Set the \"cas\" value to use a Check-And-Set operation. If not set the write will be allowed. If set to 0 a write will only be allowed if the key doesn’t exist. If the index is non-zero the write will only be allowed if the key’s current version matches the version specified in the cas parameter.",
                    "format": "map"
                  },
                  "version": {
                    "type": "integer",
                    "description": "If provided during a read, the value at the version number will be returned"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Write, Read, and Delete data in the Key-Value Store.",
        "operationId": "deleteSecretDataPath",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/secret/delete/{path}": {
      "description": "Marks one or more versions as deleted in the KV store.",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Marks one or more versions as deleted in the KV store.",
        "operationId": "postSecretDeletePath",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "versions": {
                    "type": "array",
                    "description": "The versions to be archived. The versioned data will not be deleted, but it will no longer be returned in normal get requests.",
                    "items": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/secret/destroy/{path}": {
      "description": "Permanently removes one or more versions in the KV store",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Permanently removes one or more versions in the KV store",
        "operationId": "postSecretDestroyPath",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "versions": {
                    "type": "array",
                    "description": "The versions to destroy. Their data will be permanently deleted.",
                    "items": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/secret/metadata/{path}": {
      "description": "Configures settings for the KV store",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Configures settings for the KV store",
        "operationId": "getSecretMetadataPath",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configures settings for the KV store",
        "operationId": "postSecretMetadataPath",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "cas_required": {
                    "type": "boolean",
                    "description": "If true the key will require the cas parameter to be set on all write requests. If false, the backend’s configuration will be used."
                  },
                  "delete_version_after": {
                    "type": "integer",
                    "description": "The length of time before a version is deleted. If not set, the backend's configured delete_version_after is used. Cannot be greater than the backend's delete_version_after. A zero duration clears the current setting. A negative duration will cause an error.",
                    "format": "seconds"
                  },
                  "max_versions": {
                    "type": "integer",
                    "description": "The number of versions to keep. If not set, the backend’s configured max version is used."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Configures settings for the KV store",
        "operationId": "deleteSecretMetadataPath",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/secret/undelete/{path}": {
      "description": "Undeletes one or more versions from the KV store.",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Undeletes one or more versions from the KV store.",
        "operationId": "postSecretUndeletePath",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "versions": {
                    "type": "array",
                    "description": "The versions to unarchive. The versions will be restored and their data will be returned on normal get requests.",
                    "items": {
                      "type": "integer"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/ssh/config/ca": {
      "description": "Set the SSH private key used for signing certificates.",
      "get": {
        "summary": "Set the SSH private key used for signing certificates.",
        "operationId": "getSshConfigCa",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Set the SSH private key used for signing certificates.",
        "operationId": "postSshConfigCa",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "generate_signing_key": {
                    "type": "boolean",
                    "description": "Generate SSH key pair internally rather than use the private_key and public_key fields.",
                    "default": true
                  },
                  "private_key": {
                    "type": "string",
                    "description": "Private half of the SSH key that will be used to sign certificates."
                  },
                  "public_key": {
                    "type": "string",
                    "description": "Public half of the SSH key that will be used to sign certificates."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Set the SSH private key used for signing certificates.",
        "operationId": "deleteSshConfigCa",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/ssh/config/zeroaddress": {
      "description": "Assign zero address as default CIDR block for select roles.",
      "get": {
        "summary": "Assign zero address as default CIDR block for select roles.",
        "operationId": "getSshConfigZeroaddress",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Assign zero address as default CIDR block for select roles.",
        "operationId": "postSshConfigZeroaddress",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "roles": {
                    "type": "array",
                    "description": "[Required] Comma separated list of role names which allows credentials to be requested for any IP address. CIDR blocks previously registered under these roles will be ignored.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Assign zero address as default CIDR block for select roles.",
        "operationId": "deleteSshConfigZeroaddress",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/ssh/creds/{role}": {
      "description": "Creates a credential for establishing SSH connection with the remote host.",
      "parameters": [
        {
          "name": "role",
          "description": "[Required] Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Creates a credential for establishing SSH connection with the remote host.",
        "operationId": "postSshCredsRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "ip": {
                    "type": "string",
                    "description": "[Required] IP of the remote host"
                  },
                  "username": {
                    "type": "string",
                    "description": "[Optional] Username in remote host"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/ssh/keys/{key_name}": {
      "description": "Register a shared private key with Vault.",
      "parameters": [
        {
          "name": "key_name",
          "description": "[Required] Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Register a shared private key with Vault.",
        "operationId": "postSshKeysKey_name",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "description": "[Required] SSH private key with super user privileges in host"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Register a shared private key with Vault.",
        "operationId": "deleteSshKeysKey_name",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/ssh/lookup": {
      "description": "List all the roles associated with the given IP address.",
      "post": {
        "summary": "List all the roles associated with the given IP address.",
        "operationId": "postSshLookup",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "ip": {
                    "type": "string",
                    "description": "[Required] IP address of remote host"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/ssh/public_key": {
      "description": "Retrieve the public key.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Retrieve the public key.",
        "operationId": "getSshPublic_key",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/ssh/roles": {
      "description": "Manage the 'roles' that can be created with this backend.",
      "get": {
        "summary": "Manage the 'roles' that can be created with this backend.",
        "operationId": "getSshRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/ssh/roles/{role}": {
      "description": "Manage the 'roles' that can be created with this backend.",
      "parameters": [
        {
          "name": "role",
          "description": "[Required for all types] Name of the role being created.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Manage the 'roles' that can be created with this backend.",
        "operationId": "getSshRolesRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage the 'roles' that can be created with this backend.",
        "operationId": "postSshRolesRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "admin_user": {
                    "type": "string",
                    "description": "[Required for Dynamic type] [Not applicable for OTP type] [Not applicable for CA type] Admin user at remote host. The shared key being registered should be for this user and should have root privileges. Everytime a dynamic credential is being generated for other users, Vault uses this admin username to login to remote host and install the generated credential for the other user.",
                    "x-vault-displayAttrs": {
                      "name": "Admin Username"
                    }
                  },
                  "algorithm_signer": {
                    "type": "string",
                    "description": "When supplied, this value specifies a signing algorithm for the key. Possible values: ssh-rsa, rsa-sha2-256, rsa-sha2-512.",
                    "x-vault-displayAttrs": {
                      "name": "Signing Algorithm"
                    }
                  },
                  "allow_bare_domains": {
                    "type": "boolean",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, host certificates that are requested are allowed to use the base domains listed in \"allowed_domains\", e.g. \"example.com\". This is a separate option as in some cases this can be considered a security threat."
                  },
                  "allow_host_certificates": {
                    "type": "boolean",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, certificates are allowed to be signed for use as a 'host'.",
                    "default": false
                  },
                  "allow_subdomains": {
                    "type": "boolean",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, host certificates that are requested are allowed to use subdomains of those listed in \"allowed_domains\"."
                  },
                  "allow_user_certificates": {
                    "type": "boolean",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, certificates are allowed to be signed for use as a 'user'.",
                    "default": false
                  },
                  "allow_user_key_ids": {
                    "type": "boolean",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If true, users can override the key ID for a signed certificate with the \"key_id\" field. When false, the key ID will always be the token display name. The key ID is logged by the SSH server and can be useful for auditing.",
                    "x-vault-displayAttrs": {
                      "name": "Allow User Key IDs"
                    }
                  },
                  "allowed_critical_options": {
                    "type": "string",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] A comma-separated list of critical options that certificates can have when signed. To allow any critical options, set this to an empty string."
                  },
                  "allowed_domains": {
                    "type": "string",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If this option is not specified, client can request for a signed certificate for any valid host. If only certain domains are allowed, then this list enforces it."
                  },
                  "allowed_extensions": {
                    "type": "string",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] A comma-separated list of extensions that certificates can have when signed. To allow any extensions, set this to an empty string."
                  },
                  "allowed_user_key_lengths": {
                    "type": "object",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, allows the enforcement of key types and minimum key sizes to be signed.",
                    "format": "map"
                  },
                  "allowed_users": {
                    "type": "string",
                    "description": "[Optional for all types] [Works differently for CA type] If this option is not specified, or is '*', client can request a credential for any valid user at the remote host, including the admin user. If only certain usernames are to be allowed, then this list enforces it. If this field is set, then credentials can only be created for default_user and usernames present in this list. Setting this option will enable all the users with access to this role to fetch credentials for all other usernames in this list. Use with caution. N.B.: with the CA type, an empty list means that no users are allowed; explicitly specify '*' to allow any user."
                  },
                  "allowed_users_template": {
                    "type": "boolean",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, Allowed users can be specified using identity template policies. Non-templated users are also permitted.",
                    "default": false
                  },
                  "cidr_list": {
                    "type": "string",
                    "description": "[Optional for Dynamic type] [Optional for OTP type] [Not applicable for CA type] Comma separated list of CIDR blocks for which the role is applicable for. CIDR blocks can belong to more than one role.",
                    "x-vault-displayAttrs": {
                      "name": "CIDR List"
                    }
                  },
                  "default_critical_options": {
                    "type": "object",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] Critical options certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by \"allowed_critical_options\". Defaults to none.",
                    "format": "map"
                  },
                  "default_extensions": {
                    "type": "object",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] Extensions certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by \"allowed_extensions\". Defaults to none.",
                    "format": "map"
                  },
                  "default_user": {
                    "type": "string",
                    "description": "[Required for Dynamic type] [Required for OTP type] [Optional for CA type] Default username for which a credential will be generated. When the endpoint 'creds/' is used without a username, this value will be used as default username.",
                    "x-vault-displayAttrs": {
                      "name": "Default Username"
                    }
                  },
                  "exclude_cidr_list": {
                    "type": "string",
                    "description": "[Optional for Dynamic type] [Optional for OTP type] [Not applicable for CA type] Comma separated list of CIDR blocks. IP addresses belonging to these blocks are not accepted by the role. This is particularly useful when big CIDR blocks are being used by the role and certain parts of it needs to be kept out.",
                    "x-vault-displayAttrs": {
                      "name": "Exclude CIDR List"
                    }
                  },
                  "install_script": {
                    "type": "string",
                    "description": "[Optional for Dynamic type] [Not-applicable for OTP type] [Not applicable for CA type] Script used to install and uninstall public keys in the target machine. The inbuilt default install script will be for Linux hosts. For sample script, refer the project documentation website."
                  },
                  "key": {
                    "type": "string",
                    "description": "[Required for Dynamic type] [Not applicable for OTP type] [Not applicable for CA type] Name of the registered key in Vault. Before creating the role, use the 'keys/' endpoint to create a named key."
                  },
                  "key_bits": {
                    "type": "integer",
                    "description": "[Optional for Dynamic type] [Not applicable for OTP type] [Not applicable for CA type] Length of the RSA dynamic key in bits. It is 1024 by default or it can be 2048."
                  },
                  "key_id_format": {
                    "type": "string",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] When supplied, this value specifies a custom format for the key id of a signed certificate. The following variables are available for use: '{{token_display_name}}' - The display name of the token used to make the request. '{{role_name}}' - The name of the role signing the request. '{{public_key_hash}}' - A SHA256 checksum of the public key that is being signed.",
                    "x-vault-displayAttrs": {
                      "name": "Key ID Format"
                    }
                  },
                  "key_option_specs": {
                    "type": "string",
                    "description": "[Optional for Dynamic type] [Not applicable for OTP type] [Not applicable for CA type] Comma separated option specifications which will be prefixed to RSA key in authorized_keys file. Options should be valid and comply with authorized_keys file format and should not contain spaces."
                  },
                  "key_type": {
                    "type": "string",
                    "description": "[Required for all types] Type of key used to login to hosts. It can be either 'otp', 'dynamic' or 'ca'. 'otp' type requires agent to be installed in remote hosts.",
                    "enum": [
                      "otp",
                      "dynamic",
                      "ca"
                    ],
                    "x-vault-displayAttrs": {
                      "value": "ca"
                    }
                  },
                  "max_ttl": {
                    "type": "integer",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] The maximum allowed lease duration",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "Max TTL"
                    }
                  },
                  "port": {
                    "type": "integer",
                    "description": "[Optional for Dynamic type] [Optional for OTP type] [Not applicable for CA type] Port number for SSH connection. Default is '22'. Port number does not play any role in creation of OTP. For 'otp' type, this is just a way to inform client about the port number to use. Port number will be returned to client by Vault server along with OTP.",
                    "x-vault-displayAttrs": {
                      "value": 22
                    }
                  },
                  "ttl": {
                    "type": "integer",
                    "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] The lease duration if no specific lease duration is requested. The lease duration controls the expiration of certificates issued by this backend. Defaults to the value of max_ttl.",
                    "format": "seconds",
                    "x-vault-displayAttrs": {
                      "name": "TTL"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage the 'roles' that can be created with this backend.",
        "operationId": "deleteSshRolesRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/ssh/sign/{role}": {
      "description": "Request signing an SSH key using a certain role with the provided details.",
      "parameters": [
        {
          "name": "role",
          "description": "The desired role with configuration for this request.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Request signing an SSH key using a certain role with the provided details.",
        "operationId": "postSshSignRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "cert_type": {
                    "type": "string",
                    "description": "Type of certificate to be created; either \"user\" or \"host\".",
                    "default": "user"
                  },
                  "critical_options": {
                    "type": "object",
                    "description": "Critical options that the certificate should be signed for.",
                    "format": "map"
                  },
                  "extensions": {
                    "type": "object",
                    "description": "Extensions that the certificate should be signed for.",
                    "format": "map"
                  },
                  "key_id": {
                    "type": "string",
                    "description": "Key id that the created certificate should have. If not specified, the display name of the token will be used."
                  },
                  "public_key": {
                    "type": "string",
                    "description": "SSH public key that should be signed."
                  },
                  "ttl": {
                    "type": "integer",
                    "description": "The requested Time To Live for the SSH certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be later than the role max TTL.",
                    "format": "seconds"
                  },
                  "valid_principals": {
                    "type": "string",
                    "description": "Valid principals, either usernames or hostnames, that the certificate should be signed for."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/ssh/verify": {
      "description": "Validate the OTP provided by Vault SSH Agent.",
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Validate the OTP provided by Vault SSH Agent.",
        "operationId": "postSshVerify",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "otp": {
                    "type": "string",
                    "description": "[Required] One-Time-Key that needs to be validated"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/audit": {
      "description": "List the currently enabled audit backends.",
      "x-vault-sudo": true,
      "get": {
        "summary": "List the enabled audit devices.",
        "operationId": "getSysAudit",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/audit-hash/{path}": {
      "description": "The hash of the given string via the given audit backend",
      "parameters": [
        {
          "name": "path",
          "description": "The name of the backend. Cannot be delimited. Example: \"mysql\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "The hash of the given string via the given audit backend",
        "operationId": "postSysAuditHashPath",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "input": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/audit/{path}": {
      "description": "Enable or disable audit backends.",
      "parameters": [
        {
          "name": "path",
          "description": "The name of the backend. Cannot be delimited. Example: \"mysql\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Enable a new audit device at the supplied path.",
        "operationId": "postSysAuditPath",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "type": "string",
                    "description": "User-friendly description for this audit backend."
                  },
                  "local": {
                    "type": "boolean",
                    "description": "Mark the mount as a local mount, which is not replicated and is unaffected by replication.",
                    "default": false
                  },
                  "options": {
                    "type": "object",
                    "description": "Configuration options for the audit backend.",
                    "format": "kvpairs"
                  },
                  "type": {
                    "type": "string",
                    "description": "The type of the backend. Example: \"mysql\""
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable the audit device at the given path.",
        "operationId": "deleteSysAuditPath",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/auth": {
      "description": "List the currently enabled credential backends.",
      "get": {
        "summary": "List the currently enabled credential backends.",
        "operationId": "getSysAuth",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/auth/{path}": {
      "description": "Enable a new credential backend with a name.",
      "parameters": [
        {
          "name": "path",
          "description": "The path to mount to. Cannot be delimited. Example: \"user\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Enables a new auth method.",
        "description": "After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.\n\nFor example, enable the \"foo\" auth method will make it accessible at /auth/foo.",
        "operationId": "postSysAuthPath",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "config": {
                    "type": "object",
                    "description": "Configuration for this mount, such as plugin_name.",
                    "format": "map"
                  },
                  "description": {
                    "type": "string",
                    "description": "User-friendly description for this credential backend."
                  },
                  "external_entropy_access": {
                    "type": "boolean",
                    "description": "Whether to give the mount access to Vault's external entropy.",
                    "default": false
                  },
                  "local": {
                    "type": "boolean",
                    "description": "Mark the mount as a local mount, which is not replicated and is unaffected by replication.",
                    "default": false
                  },
                  "options": {
                    "type": "object",
                    "description": "The options to pass into the backend. Should be a json object with string keys and values.",
                    "format": "kvpairs"
                  },
                  "plugin_name": {
                    "type": "string",
                    "description": "Name of the auth plugin to use based from the name in the plugin catalog."
                  },
                  "seal_wrap": {
                    "type": "boolean",
                    "description": "Whether to turn on seal wrapping for the mount.",
                    "default": false
                  },
                  "type": {
                    "type": "string",
                    "description": "The type of the backend. Example: \"userpass\""
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable the auth method at the given auth path",
        "operationId": "deleteSysAuthPath",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/auth/{path}/tune": {
      "description": "Tune the configuration parameters for an auth path.",
      "parameters": [
        {
          "name": "path",
          "description": "Tune the configuration parameters for an auth path.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Reads the given auth path's configuration.",
        "description": "This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.",
        "operationId": "getSysAuthPathTune",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Tune configuration parameters for a given auth path.",
        "description": "This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.",
        "operationId": "postSysAuthPathTune",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allowed_response_headers": {
                    "type": "array",
                    "description": "A list of headers to whitelist and allow a plugin to set on responses.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "audit_non_hmac_request_keys": {
                    "type": "array",
                    "description": "The list of keys in the request data object that will not be HMAC'ed by audit devices.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "audit_non_hmac_response_keys": {
                    "type": "array",
                    "description": "The list of keys in the response data object that will not be HMAC'ed by audit devices.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "default_lease_ttl": {
                    "type": "string",
                    "description": "The default lease TTL for this mount."
                  },
                  "description": {
                    "type": "string",
                    "description": "User-friendly description for this credential backend."
                  },
                  "listing_visibility": {
                    "type": "string",
                    "description": "Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and ''."
                  },
                  "max_lease_ttl": {
                    "type": "string",
                    "description": "The max lease TTL for this mount."
                  },
                  "options": {
                    "type": "object",
                    "description": "The options to pass into the backend. Should be a json object with string keys and values.",
                    "format": "kvpairs"
                  },
                  "passthrough_request_headers": {
                    "type": "array",
                    "description": "A list of headers to whitelist and pass from the request to the plugin.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "token_type": {
                    "type": "string",
                    "description": "The type of token to issue (service or batch)."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/capabilities": {
      "description": "Fetches the capabilities of the given token on the given path.",
      "post": {
        "summary": "Fetches the capabilities of the given token on the given path.",
        "operationId": "postSysCapabilities",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "array",
                    "description": "Use 'paths' instead.",
                    "items": {
                      "type": "string"
                    },
                    "deprecated": true
                  },
                  "paths": {
                    "type": "array",
                    "description": "Paths on which capabilities are being queried.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "token": {
                    "type": "string",
                    "description": "Token for which capabilities are being queried."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/capabilities-accessor": {
      "description": "Fetches the capabilities of the token associated with the given token, on the given path.",
      "post": {
        "summary": "Fetches the capabilities of the token associated with the given token, on the given path.",
        "operationId": "postSysCapabilitiesAccessor",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "accessor": {
                    "type": "string",
                    "description": "Accessor of the token for which capabilities are being queried."
                  },
                  "path": {
                    "type": "array",
                    "description": "Use 'paths' instead.",
                    "items": {
                      "type": "string"
                    },
                    "deprecated": true
                  },
                  "paths": {
                    "type": "array",
                    "description": "Paths on which capabilities are being queried.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/capabilities-self": {
      "description": "Fetches the capabilities of the given token on the given path.",
      "post": {
        "summary": "Fetches the capabilities of the given token on the given path.",
        "operationId": "postSysCapabilitiesSelf",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "array",
                    "description": "Use 'paths' instead.",
                    "items": {
                      "type": "string"
                    },
                    "deprecated": true
                  },
                  "paths": {
                    "type": "array",
                    "description": "Paths on which capabilities are being queried.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "token": {
                    "type": "string",
                    "description": "Token for which capabilities are being queried."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/config/auditing/request-headers": {
      "description": "Lists the headers configured to be audited.",
      "x-vault-sudo": true,
      "get": {
        "summary": "List the request headers that are configured to be audited.",
        "operationId": "getSysConfigAuditingRequestHeaders",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/config/auditing/request-headers/{header}": {
      "description": "Configures the headers sent to the audit logs.",
      "parameters": [
        {
          "name": "header",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "List the information for the given request header.",
        "operationId": "getSysConfigAuditingRequestHeadersHeader",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enable auditing of a header.",
        "operationId": "postSysConfigAuditingRequestHeadersHeader",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "hmac": {
                    "type": "boolean"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable auditing of the given request header.",
        "operationId": "deleteSysConfigAuditingRequestHeadersHeader",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/config/cors": {
      "description": "This path responds to the following HTTP methods. GET / Returns the configuration of the CORS setting. POST / Sets the comma-separated list of origins that can make cross-origin requests. DELETE / Clears the CORS configuration and disables acceptance of CORS requests.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the current CORS settings.",
        "operationId": "getSysConfigCors",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the CORS settings.",
        "operationId": "postSysConfigCors",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allowed_headers": {
                    "type": "array",
                    "description": "A comma-separated string or array of strings indicating headers that are allowed on cross-origin requests.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "allowed_origins": {
                    "type": "array",
                    "description": "A comma-separated string or array of strings indicating origins that may make cross-origin requests.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "enable": {
                    "type": "boolean",
                    "description": "Enables or disables CORS headers on requests."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove any CORS settings.",
        "operationId": "deleteSysConfigCors",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/config/state/sanitized": {
      "get": {
        "summary": "Return a sanitized version of the Vault server configuration.",
        "description": "The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.",
        "operationId": "getSysConfigStateSanitized",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/config/ui/headers/": {
      "description": "This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Return a list of configured UI headers.",
        "operationId": "getSysConfigUiHeaders",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/config/ui/headers/{header}": {
      "description": "This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.",
      "parameters": [
        {
          "name": "header",
          "description": "The name of the header.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the given UI header's configuration",
        "operationId": "getSysConfigUiHeadersHeader",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the values to be returned for the UI header.",
        "operationId": "postSysConfigUiHeadersHeader",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "multivalue": {
                    "type": "boolean",
                    "description": "Returns multiple values if true"
                  },
                  "values": {
                    "type": "array",
                    "description": "The values to set the header.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove a UI header.",
        "operationId": "deleteSysConfigUiHeadersHeader",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/generate-root": {
      "description": "Reads, generates, or deletes a root token regeneration process.",
      "get": {
        "summary": "Read the configuration and progress of the current root generation attempt.",
        "operationId": "getSysGenerateRoot",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initializes a new root generation attempt.",
        "description": "Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.",
        "operationId": "postSysGenerateRoot",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "pgp_key": {
                    "type": "string",
                    "description": "Specifies a base64-encoded PGP public key."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancels any in-progress root generation attempt.",
        "operationId": "deleteSysGenerateRoot",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/generate-root/attempt": {
      "description": "Reads, generates, or deletes a root token regeneration process.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Read the configuration and progress of the current root generation attempt.",
        "operationId": "getSysGenerateRootAttempt",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initializes a new root generation attempt.",
        "description": "Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.",
        "operationId": "postSysGenerateRootAttempt",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "pgp_key": {
                    "type": "string",
                    "description": "Specifies a base64-encoded PGP public key."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancels any in-progress root generation attempt.",
        "operationId": "deleteSysGenerateRootAttempt",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/generate-root/update": {
      "description": "Reads, generates, or deletes a root token regeneration process.",
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Enter a single master key share to progress the root generation attempt.",
        "description": "If the threshold number of master key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.",
        "operationId": "postSysGenerateRootUpdate",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "description": "Specifies a single master key share."
                  },
                  "nonce": {
                    "type": "string",
                    "description": "Specifies the nonce of the attempt."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/health": {
      "description": "Checks the health status of the Vault.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Returns the health status of Vault.",
        "operationId": "getSysHealth",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "initialized, unsealed, and active"
          },
          "429": {
            "description": "unsealed and standby"
          },
          "472": {
            "description": "data recovery mode replication secondary and active"
          },
          "501": {
            "description": "not initialized"
          },
          "503": {
            "description": "sealed"
          }
        }
      }
    },
    "/sys/host-info": {
      "description": "Information about the host instance that this Vault server is running on.",
      "get": {
        "summary": "Information about the host instance that this Vault server is running on.",
        "description": "Information about the host instance that this Vault server is running on.\n\t\tThe information that gets collected includes host hardware information, and CPU,\n\t\tdisk, and memory utilization",
        "operationId": "getSysHostInfo",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/init": {
      "description": "Initializes or returns the initialization status of the Vault.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Returns the initialization status of Vault.",
        "operationId": "getSysInit",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initialize a new Vault.",
        "description": "The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.",
        "operationId": "postSysInit",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "pgp_keys": {
                    "type": "array",
                    "description": "Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `secret_shares`.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "recovery_pgp_keys": {
                    "type": "array",
                    "description": "Specifies an array of PGP public keys used to encrypt the output recovery keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `recovery_shares`.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "recovery_shares": {
                    "type": "integer",
                    "description": "Specifies the number of shares to split the recovery key into."
                  },
                  "recovery_threshold": {
                    "type": "integer",
                    "description": "Specifies the number of shares required to reconstruct the recovery key. This must be less than or equal to `recovery_shares`."
                  },
                  "root_token_pgp_key": {
                    "type": "string",
                    "description": "Specifies a PGP public key used to encrypt the initial root token. The key must be base64-encoded from its original binary representation."
                  },
                  "secret_shares": {
                    "type": "integer",
                    "description": "Specifies the number of shares to split the master key into."
                  },
                  "secret_threshold": {
                    "type": "integer",
                    "description": "Specifies the number of shares required to reconstruct the master key. This must be less than or equal secret_shares. If using Vault HSM with auto-unsealing, this value must be the same as `secret_shares`."
                  },
                  "stored_shares": {
                    "type": "integer",
                    "description": "Specifies the number of shares that should be encrypted by the HSM and stored for auto-unsealing. Currently must be the same as `secret_shares`."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/activity": {
      "description": "Query the historical count of clients.",
      "get": {
        "summary": "Report the client count metrics, for this namespace and all child namespaces.",
        "operationId": "getSysInternalCountersActivity",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/activity/monthly": {
      "description": "Count of active clients so far this month.",
      "get": {
        "summary": "Report the number of clients for this month, for this namespace and all child namespaces.",
        "operationId": "getSysInternalCountersActivityMonthly",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/config": {
      "description": "Control the collection and reporting of client counts.",
      "get": {
        "summary": "Read the client count tracking configuration.",
        "operationId": "getSysInternalCountersConfig",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enable or disable collection of client count, set retention period, or set default reporting period.",
        "operationId": "postSysInternalCountersConfig",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "default_report_months": {
                    "type": "integer",
                    "description": "Number of months to report if no start date specified.",
                    "default": 12
                  },
                  "enabled": {
                    "type": "string",
                    "description": "Enable or disable collection of client count: enable, disable, or default.",
                    "default": "default"
                  },
                  "retention_months": {
                    "type": "integer",
                    "description": "Number of months of client data to retain. Setting to 0 will clear all existing data.",
                    "default": 24
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/entities": {
      "description": "Count of active entities in this Vault cluster."
    },
    "/sys/internal/counters/requests": {
      "description": "Count of requests seen by this Vault cluster over time."
    },
    "/sys/internal/counters/tokens": {
      "description": "Count of active tokens in this Vault cluster."
    },
    "/sys/internal/specs/openapi": {
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Generate an OpenAPI 3 document of all mounted paths.",
        "operationId": "getSysInternalSpecsOpenapi",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/ui/feature-flags": {
      "description": "Enabled feature flags. Internal API; its location, inputs, and outputs may change.",
      "get": {
        "summary": "Lists enabled feature flags.",
        "operationId": "getSysInternalUiFeatureFlags",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/ui/mounts": {
      "description": "Information about mounts returned according to their tuned visibility. Internal API; its location, inputs, and outputs may change.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Lists all enabled and visible auth and secrets mounts.",
        "operationId": "getSysInternalUiMounts",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/ui/mounts/{path}": {
      "description": "Information about mounts returned according to their tuned visibility. Internal API; its location, inputs, and outputs may change.",
      "parameters": [
        {
          "name": "path",
          "description": "The path of the mount.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Return information about the given mount.",
        "operationId": "getSysInternalUiMountsPath",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/ui/namespaces": {
      "description": "Information about visible child namespaces. Internal API; its location, inputs, and outputs may change.",
      "x-vault-unauthenticated": true
    },
    "/sys/internal/ui/resultant-acl": {
      "description": "Information about a token's resultant ACL. Internal API; its location, inputs, and outputs may change."
    },
    "/sys/key-status": {
      "description": "Provides information about the backend encryption key.",
      "get": {
        "summary": "Provides information about the backend encryption key.",
        "operationId": "getSysKeyStatus",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leader": {
      "description": "Check the high availability status and current leader of Vault",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Returns the high availability status and current leader instance of Vault.",
        "operationId": "getSysLeader",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/lookup": {
      "description": "View or list lease metadata.",
      "post": {
        "summary": "Retrieve lease metadata.",
        "operationId": "postSysLeasesLookup",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/lookup/": {
      "description": "View or list lease metadata.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Returns a list of lease ids.",
        "operationId": "getSysLeasesLookup",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/lookup/{prefix}": {
      "description": "View or list lease metadata.",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to list leases under. Example: \"aws/creds/deploy\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Returns a list of lease ids.",
        "operationId": "getSysLeasesLookupPrefix",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/renew": {
      "description": "Renew a lease on a secret",
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "operationId": "postSysLeasesRenew",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "increment": {
                    "type": "integer",
                    "description": "The desired increment in seconds to the lease",
                    "format": "seconds"
                  },
                  "lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  },
                  "url_lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/renew/{url_lease_id}": {
      "description": "Renew a lease on a secret",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "operationId": "postSysLeasesRenewUrl_lease_id",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "increment": {
                    "type": "integer",
                    "description": "The desired increment in seconds to the lease",
                    "format": "seconds"
                  },
                  "lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/revoke": {
      "description": "Revoke a leased secret immediately",
      "post": {
        "summary": "Revokes a lease immediately.",
        "operationId": "postSysLeasesRevoke",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  },
                  "sync": {
                    "type": "boolean",
                    "description": "Whether or not to perform the revocation synchronously",
                    "default": true
                  },
                  "url_lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/revoke-force/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix, ignoring errors.",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets or tokens generated under a given prefix immediately",
        "description": "Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.\n\nBy ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.",
        "operationId": "postSysLeasesRevokeForcePrefix",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/revoke-prefix/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately.",
        "operationId": "postSysLeasesRevokePrefixPrefix",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "sync": {
                    "type": "boolean",
                    "description": "Whether or not to perform the revocation synchronously",
                    "default": true
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/revoke/{url_lease_id}": {
      "description": "Revoke a leased secret immediately",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Revokes a lease immediately.",
        "operationId": "postSysLeasesRevokeUrl_lease_id",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  },
                  "sync": {
                    "type": "boolean",
                    "description": "Whether or not to perform the revocation synchronously",
                    "default": true
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/tidy": {
      "description": "This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.",
      "post": {
        "summary": "This endpoint performs cleanup tasks that can be run if certain error\nconditions have occurred.",
        "operationId": "postSysLeasesTidy",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/metrics": {
      "description": "Export the metrics aggregated for telemetry purpose.",
      "parameters": [
        {
          "name": "format",
          "description": "Format to export metrics into. Currently accepts only \"prometheus\".",
          "in": "query",
          "schema": {
            "type": "string"
          }
        }
      ],
      "get": {
        "summary": "Export the metrics aggregated for telemetry purpose.",
        "operationId": "getSysMetrics",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/monitor": {
      "parameters": [
        {
          "name": "log_level",
          "description": "Log level to view system logs at. Currently supported values are \"trace\", \"debug\", \"info\", \"warn\", \"error\".",
          "in": "query",
          "schema": {
            "type": "string"
          }
        }
      ],
      "get": {
        "operationId": "getSysMonitor",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/mounts": {
      "description": "List the currently mounted backends.",
      "get": {
        "summary": "List the currently mounted backends.",
        "operationId": "getSysMounts",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/mounts/{path}": {
      "description": "Mount a new backend at a new path.",
      "parameters": [
        {
          "name": "path",
          "description": "The path to mount to. Example: \"aws/east\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Enable a new secrets engine at the given path.",
        "operationId": "postSysMountsPath",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "config": {
                    "type": "object",
                    "description": "Configuration for this mount, such as default_lease_ttl and max_lease_ttl.",
                    "format": "map"
                  },
                  "description": {
                    "type": "string",
                    "description": "User-friendly description for this mount."
                  },
                  "external_entropy_access": {
                    "type": "boolean",
                    "description": "Whether to give the mount access to Vault's external entropy.",
                    "default": false
                  },
                  "local": {
                    "type": "boolean",
                    "description": "Mark the mount as a local mount, which is not replicated and is unaffected by replication.",
                    "default": false
                  },
                  "options": {
                    "type": "object",
                    "description": "The options to pass into the backend. Should be a json object with string keys and values.",
                    "format": "kvpairs"
                  },
                  "plugin_name": {
                    "type": "string",
                    "description": "Name of the plugin to mount based from the name registered in the plugin catalog."
                  },
                  "seal_wrap": {
                    "type": "boolean",
                    "description": "Whether to turn on seal wrapping for the mount.",
                    "default": false
                  },
                  "type": {
                    "type": "string",
                    "description": "The type of the backend. Example: \"passthrough\""
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable the mount point specified at the given path.",
        "operationId": "deleteSysMountsPath",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/mounts/{path}/tune": {
      "description": "Tune backend configuration parameters for this mount.",
      "parameters": [
        {
          "name": "path",
          "description": "The path to mount to. Example: \"aws/east\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Tune backend configuration parameters for this mount.",
        "operationId": "getSysMountsPathTune",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Tune backend configuration parameters for this mount.",
        "operationId": "postSysMountsPathTune",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allowed_response_headers": {
                    "type": "array",
                    "description": "A list of headers to whitelist and allow a plugin to set on responses.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "audit_non_hmac_request_keys": {
                    "type": "array",
                    "description": "The list of keys in the request data object that will not be HMAC'ed by audit devices.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "audit_non_hmac_response_keys": {
                    "type": "array",
                    "description": "The list of keys in the response data object that will not be HMAC'ed by audit devices.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "default_lease_ttl": {
                    "type": "string",
                    "description": "The default lease TTL for this mount."
                  },
                  "description": {
                    "type": "string",
                    "description": "User-friendly description for this credential backend."
                  },
                  "listing_visibility": {
                    "type": "string",
                    "description": "Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and ''."
                  },
                  "max_lease_ttl": {
                    "type": "string",
                    "description": "The max lease TTL for this mount."
                  },
                  "options": {
                    "type": "object",
                    "description": "The options to pass into the backend. Should be a json object with string keys and values.",
                    "format": "kvpairs"
                  },
                  "passthrough_request_headers": {
                    "type": "array",
                    "description": "A list of headers to whitelist and pass from the request to the plugin.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "token_type": {
                    "type": "string",
                    "description": "The type of token to issue (service or batch)."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/plugins/catalog": {
      "description": "Lists all the plugins known to Vault",
      "get": {
        "summary": "Lists all the plugins known to Vault",
        "operationId": "getSysPluginsCatalog",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/plugins/catalog/{name}": {
      "description": "Configures the plugins known to Vault",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the plugin",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the configuration data for the plugin with the given name.",
        "operationId": "getSysPluginsCatalogName",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register a new plugin, or updates an existing one with the supplied name.",
        "operationId": "postSysPluginsCatalogName",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "args": {
                    "type": "array",
                    "description": "The args passed to plugin command.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "command": {
                    "type": "string",
                    "description": "The command used to start the plugin. The executable defined in this command must exist in vault's plugin directory."
                  },
                  "env": {
                    "type": "array",
                    "description": "The environment variables passed to plugin command. Each entry is of the form \"key=value\".",
                    "items": {
                      "type": "string"
                    }
                  },
                  "sha256": {
                    "type": "string",
                    "description": "The SHA256 sum of the executable used in the command field. This should be HEX encoded."
                  },
                  "sha_256": {
                    "type": "string",
                    "description": "The SHA256 sum of the executable used in the command field. This should be HEX encoded."
                  },
                  "type": {
                    "type": "string",
                    "description": "The type of the plugin, may be auth, secret, or database"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove the plugin with the given name.",
        "operationId": "deleteSysPluginsCatalogName",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/plugins/catalog/{type}": {
      "description": "Configures the plugins known to Vault",
      "parameters": [
        {
          "name": "type",
          "description": "The type of the plugin, may be auth, secret, or database",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "List the plugins in the catalog.",
        "operationId": "getSysPluginsCatalogType",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/plugins/catalog/{type}/{name}": {
      "description": "Configures the plugins known to Vault",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the plugin",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "type",
          "description": "The type of the plugin, may be auth, secret, or database",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the configuration data for the plugin with the given name.",
        "operationId": "getSysPluginsCatalogTypeName",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register a new plugin, or updates an existing one with the supplied name.",
        "operationId": "postSysPluginsCatalogTypeName",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "args": {
                    "type": "array",
                    "description": "The args passed to plugin command.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "command": {
                    "type": "string",
                    "description": "The command used to start the plugin. The executable defined in this command must exist in vault's plugin directory."
                  },
                  "env": {
                    "type": "array",
                    "description": "The environment variables passed to plugin command. Each entry is of the form \"key=value\".",
                    "items": {
                      "type": "string"
                    }
                  },
                  "sha256": {
                    "type": "string",
                    "description": "The SHA256 sum of the executable used in the command field. This should be HEX encoded."
                  },
                  "sha_256": {
                    "type": "string",
                    "description": "The SHA256 sum of the executable used in the command field. This should be HEX encoded."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove the plugin with the given name.",
        "operationId": "deleteSysPluginsCatalogTypeName",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/plugins/reload/backend": {
      "description": "Reload mounts that use a particular backend plugin.",
      "post": {
        "summary": "Reload mounted plugin backends.",
        "description": "Either the plugin name (`plugin`) or the desired plugin backend mounts (`mounts`) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (`scope`) is provided and is (`global`), the plugin(s) are reloaded globally.",
        "operationId": "postSysPluginsReloadBackend",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "mounts": {
                    "type": "array",
                    "description": "The mount paths of the plugin backends to reload.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "plugin": {
                    "type": "string",
                    "description": "The name of the plugin to reload, as registered in the plugin catalog."
                  },
                  "scope": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/policies/acl": {
      "description": "List the configured access control policies.",
      "get": {
        "summary": "List the configured access control policies.",
        "operationId": "getSysPoliciesAcl",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/policies/acl/{name}": {
      "description": "Read, Modify, or Delete an access control policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the policy. Example: \"ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve information about the named ACL policy.",
        "operationId": "getSysPoliciesAclName",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Add a new or update an existing ACL policy.",
        "operationId": "postSysPoliciesAclName",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "policy": {
                    "type": "string",
                    "description": "The rules of the policy."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the ACL policy with the given name.",
        "operationId": "deleteSysPoliciesAclName",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/policies/password/{name}": {
      "description": "Read, Modify, or Delete a password policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the password policy.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve an existing password policy.",
        "operationId": "getSysPoliciesPasswordName",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Add a new or update an existing password policy.",
        "operationId": "postSysPoliciesPasswordName",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "policy": {
                    "type": "string",
                    "description": "The password policy"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a password policy.",
        "operationId": "deleteSysPoliciesPasswordName",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/policies/password/{name}/generate": {
      "description": "Generate a password from an existing password policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the password policy.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Generate a password from an existing password policy.",
        "operationId": "getSysPoliciesPasswordNameGenerate",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/policy": {
      "description": "List the configured access control policies.",
      "get": {
        "summary": "List the configured access control policies.",
        "operationId": "getSysPolicy",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/policy/{name}": {
      "description": "Read, Modify, or Delete an access control policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the policy. Example: \"ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the policy body for the named policy.",
        "operationId": "getSysPolicyName",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Add a new or update an existing policy.",
        "operationId": "postSysPolicyName",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "policy": {
                    "type": "string",
                    "description": "The rules of the policy."
                  },
                  "rules": {
                    "type": "string",
                    "description": "The rules of the policy.",
                    "deprecated": true
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the policy with the given name.",
        "operationId": "deleteSysPolicyName",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/pprof/": {
      "get": {
        "summary": "Returns an HTML page listing the available profiles.",
        "description": "Returns an HTML page listing the available \nprofiles. This should be mainly accessed via browsers or applications that can \nrender pages.",
        "operationId": "getSysPprof",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/allocs": {
      "get": {
        "summary": "Returns a sampling of all past memory allocations.",
        "description": "Returns a sampling of all past memory allocations.",
        "operationId": "getSysPprofAllocs",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/block": {
      "get": {
        "summary": "Returns stack traces that led to blocking on synchronization primitives",
        "description": "Returns stack traces that led to blocking on synchronization primitives",
        "operationId": "getSysPprofBlock",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/cmdline": {
      "get": {
        "summary": "Returns the running program's command line.",
        "description": "Returns the running program's command line, with arguments separated by NUL bytes.",
        "operationId": "getSysPprofCmdline",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/goroutine": {
      "get": {
        "summary": "Returns stack traces of all current goroutines.",
        "description": "Returns stack traces of all current goroutines.",
        "operationId": "getSysPprofGoroutine",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/heap": {
      "get": {
        "summary": "Returns a sampling of memory allocations of live object.",
        "description": "Returns a sampling of memory allocations of live object.",
        "operationId": "getSysPprofHeap",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/mutex": {
      "get": {
        "summary": "Returns stack traces of holders of contended mutexes",
        "description": "Returns stack traces of holders of contended mutexes",
        "operationId": "getSysPprofMutex",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/profile": {
      "get": {
        "summary": "Returns a pprof-formatted cpu profile payload.",
        "description": "Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.",
        "operationId": "getSysPprofProfile",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/symbol": {
      "get": {
        "summary": "Returns the program counters listed in the request.",
        "description": "Returns the program counters listed in the request.",
        "operationId": "getSysPprofSymbol",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/threadcreate": {
      "get": {
        "summary": "Returns stack traces that led to the creation of new OS threads",
        "description": "Returns stack traces that led to the creation of new OS threads",
        "operationId": "getSysPprofThreadcreate",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/trace": {
      "get": {
        "summary": "Returns the execution trace in binary form.",
        "description": "Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.",
        "operationId": "getSysPprofTrace",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/quotas/config": {
      "description": "Create, update and read the quota configuration.",
      "get": {
        "operationId": "getSysQuotasConfig",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "postSysQuotasConfig",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "enable_rate_limit_audit_logging": {
                    "type": "boolean",
                    "description": "If set, starts audit logging of requests that get rejected due to rate limit quota rule violations."
                  },
                  "enable_rate_limit_response_headers": {
                    "type": "boolean",
                    "description": "If set, additional rate limit quota HTTP headers will be added to responses."
                  },
                  "rate_limit_exempt_paths": {
                    "type": "array",
                    "description": "Specifies the list of exempt paths from all rate limit quotas. If empty no paths will be exempt.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/quotas/rate-limit": {
      "description": "Lists the names of all the rate limit quotas.",
      "get": {
        "operationId": "getSysQuotasRateLimit",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/quotas/rate-limit/{name}": {
      "description": "Get, create or update rate limit resource quota for an optional namespace or mount.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the quota rule.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "getSysQuotasRateLimitName",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "postSysQuotasRateLimitName",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "block_interval": {
                    "type": "integer",
                    "description": "If set, when a client reaches a rate limit threshold, the client will be prohibited from any further requests until after the 'block_interval' has elapsed.",
                    "format": "seconds"
                  },
                  "interval": {
                    "type": "integer",
                    "description": "The duration to enforce rate limiting for (default '1s').",
                    "format": "seconds"
                  },
                  "path": {
                    "type": "string",
                    "description": "Path of the mount or namespace to apply the quota. A blank path configures a global quota. For example namespace1/ adds a quota to a full namespace, namespace1/auth/userpass adds a quota to userpass in namespace1."
                  },
                  "rate": {
                    "type": "number",
                    "description": "The maximum number of requests in a given interval to be allowed by the quota rule. The 'rate' must be positive.",
                    "format": "float"
                  },
                  "type": {
                    "type": "string",
                    "description": "Type of the quota rule."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "deleteSysQuotasRateLimitName",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/raw": {
      "description": "Write, Read, and Delete data directly in the Storage backend.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Read the value of the key at the given path.",
        "operationId": "getSysRaw",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the value of the key at the given path.",
        "operationId": "postSysRaw",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the key with given path.",
        "operationId": "deleteSysRaw",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/raw/{path}": {
      "description": "Write, Read, and Delete data directly in the Storage backend.",
      "parameters": [
        {
          "name": "path",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Read the value of the key at the given path.",
        "operationId": "getSysRawPath",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the value of the key at the given path.",
        "operationId": "postSysRawPath",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "value": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the key with given path.",
        "operationId": "deleteSysRawPath",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/rekey/backup": {
      "description": "Allows fetching or deleting the backup of the rotated unseal keys.",
      "get": {
        "summary": "Return the backup copy of PGP-encrypted unseal keys.",
        "operationId": "getSysRekeyBackup",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the backup copy of PGP-encrypted unseal keys.",
        "operationId": "deleteSysRekeyBackup",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/rekey/init": {
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Reads the configuration and progress of the current rekey attempt.",
        "operationId": "getSysRekeyInit",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initializes a new rekey attempt.",
        "description": "Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.",
        "operationId": "postSysRekeyInit",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "backup": {
                    "type": "boolean",
                    "description": "Specifies if using PGP-encrypted keys, whether Vault should also store a plaintext backup of the PGP-encrypted keys."
                  },
                  "pgp_keys": {
                    "type": "array",
                    "description": "Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as secret_shares.",
                    "items": {
                      "type": "string"
                    }
                  },
                  "require_verification": {
                    "type": "boolean",
                    "description": "Turns on verification functionality"
                  },
                  "secret_shares": {
                    "type": "integer",
                    "description": "Specifies the number of shares to split the master key into."
                  },
                  "secret_threshold": {
                    "type": "integer",
                    "description": "Specifies the number of shares required to reconstruct the master key. This must be less than or equal secret_shares. If using Vault HSM with auto-unsealing, this value must be the same as secret_shares."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancels any in-progress rekey.",
        "description": "This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.",
        "operationId": "deleteSysRekeyInit",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/rekey/recovery-key-backup": {
      "description": "Allows fetching or deleting the backup of the rotated unseal keys.",
      "get": {
        "summary": "Allows fetching or deleting the backup of the rotated unseal keys.",
        "operationId": "getSysRekeyRecoveryKeyBackup",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Allows fetching or deleting the backup of the rotated unseal keys.",
        "operationId": "deleteSysRekeyRecoveryKeyBackup",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/rekey/update": {
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Enter a single master key share to progress the rekey of the Vault.",
        "operationId": "postSysRekeyUpdate",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "description": "Specifies a single master key share."
                  },
                  "nonce": {
                    "type": "string",
                    "description": "Specifies the nonce of the rekey attempt."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/rekey/verify": {
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Read the configuration and progress of the current rekey verification attempt.",
        "operationId": "getSysRekeyVerify",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enter a single new key share to progress the rekey verification operation.",
        "operationId": "postSysRekeyVerify",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "description": "Specifies a single master share key from the new set of shares."
                  },
                  "nonce": {
                    "type": "string",
                    "description": "Specifies the nonce of the rekey verification operation."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancel any in-progress rekey verification operation.",
        "description": "This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rekey/init`, this only resets the current verification operation, not the entire rekey atttempt.",
        "operationId": "deleteSysRekeyVerify",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/remount": {
      "description": "Move the mount point of an already-mounted backend.",
      "x-vault-sudo": true,
      "post": {
        "summary": "Move the mount point of an already-mounted backend.",
        "operationId": "postSysRemount",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "from": {
                    "type": "string",
                    "description": "The previous mount point."
                  },
                  "to": {
                    "type": "string",
                    "description": "The new mount point."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/renew": {
      "description": "Renew a lease on a secret",
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "operationId": "postSysRenew",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "increment": {
                    "type": "integer",
                    "description": "The desired increment in seconds to the lease",
                    "format": "seconds"
                  },
                  "lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  },
                  "url_lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/renew/{url_lease_id}": {
      "description": "Renew a lease on a secret",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "operationId": "postSysRenewUrl_lease_id",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "increment": {
                    "type": "integer",
                    "description": "The desired increment in seconds to the lease",
                    "format": "seconds"
                  },
                  "lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/replication/status": {
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "getSysReplicationStatus",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/revoke": {
      "description": "Revoke a leased secret immediately",
      "post": {
        "summary": "Revokes a lease immediately.",
        "operationId": "postSysRevoke",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  },
                  "sync": {
                    "type": "boolean",
                    "description": "Whether or not to perform the revocation synchronously",
                    "default": true
                  },
                  "url_lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/revoke-force/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix, ignoring errors.",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets or tokens generated under a given prefix immediately",
        "description": "Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.\n\nBy ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.",
        "operationId": "postSysRevokeForcePrefix",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/revoke-prefix/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately.",
        "operationId": "postSysRevokePrefixPrefix",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "sync": {
                    "type": "boolean",
                    "description": "Whether or not to perform the revocation synchronously",
                    "default": true
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/revoke/{url_lease_id}": {
      "description": "Revoke a leased secret immediately",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Revokes a lease immediately.",
        "operationId": "postSysRevokeUrl_lease_id",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "lease_id": {
                    "type": "string",
                    "description": "The lease identifier to renew. This is included with a lease."
                  },
                  "sync": {
                    "type": "boolean",
                    "description": "Whether or not to perform the revocation synchronously",
                    "default": true
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/rotate": {
      "description": "Rotates the backend encryption key used to persist data.",
      "x-vault-sudo": true,
      "post": {
        "summary": "Rotates the backend encryption key used to persist data.",
        "operationId": "postSysRotate",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/rotate/config": {
      "description": "Configures settings related to the backend encryption key management.",
      "get": {
        "operationId": "getSysRotateConfig",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "postSysRotateConfig",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "enabled": {
                    "type": "boolean",
                    "description": "Whether automatic rotation is enabled."
                  },
                  "interval": {
                    "type": "integer",
                    "description": "How long after installation of an active key term that the key will be automatically rotated.",
                    "format": "seconds"
                  },
                  "max_operations": {
                    "type": "integer",
                    "description": "The number of encryption operations performed before the barrier key is automatically rotated."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/seal": {
      "description": "Seals the Vault.",
      "post": {
        "summary": "Seal the Vault.",
        "operationId": "postSysSeal",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/seal-status": {
      "description": "Returns the seal status of the Vault.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Check the seal status of a Vault.",
        "operationId": "getSysSealStatus",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/step-down": {
      "post": {
        "summary": "Cause the node to give up active status.",
        "description": "This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.",
        "operationId": "postSysStepDown",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/tools/hash": {
      "description": "Generate a hash sum for input data",
      "post": {
        "summary": "Generate a hash sum for input data",
        "operationId": "postSysToolsHash",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "algorithm": {
                    "type": "string",
                    "description": "Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to \"sha2-256\".",
                    "default": "sha2-256"
                  },
                  "format": {
                    "type": "string",
                    "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"hex\".",
                    "default": "hex"
                  },
                  "input": {
                    "type": "string",
                    "description": "The base64-encoded input data"
                  },
                  "urlalgorithm": {
                    "type": "string",
                    "description": "Algorithm to use (POST URL parameter)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/tools/hash/{urlalgorithm}": {
      "description": "Generate a hash sum for input data",
      "parameters": [
        {
          "name": "urlalgorithm",
          "description": "Algorithm to use (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate a hash sum for input data",
        "operationId": "postSysToolsHashUrlalgorithm",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "algorithm": {
                    "type": "string",
                    "description": "Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to \"sha2-256\".",
                    "default": "sha2-256"
                  },
                  "format": {
                    "type": "string",
                    "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"hex\".",
                    "default": "hex"
                  },
                  "input": {
                    "type": "string",
                    "description": "The base64-encoded input data"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/tools/random": {
      "description": "Generate random bytes",
      "post": {
        "summary": "Generate random bytes",
        "operationId": "postSysToolsRandom",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "bytes": {
                    "type": "integer",
                    "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
                    "default": 32
                  },
                  "format": {
                    "type": "string",
                    "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
                    "default": "base64"
                  },
                  "urlbytes": {
                    "type": "string",
                    "description": "The number of bytes to generate (POST URL parameter)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/tools/random/{urlbytes}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "urlbytes",
          "description": "The number of bytes to generate (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "operationId": "postSysToolsRandomUrlbytes",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "bytes": {
                    "type": "integer",
                    "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
                    "default": 32
                  },
                  "format": {
                    "type": "string",
                    "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
                    "default": "base64"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/unseal": {
      "description": "Unseals the Vault.",
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Unseal the Vault.",
        "operationId": "postSysUnseal",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "description": "Specifies a single master key share. This is required unless reset is true."
                  },
                  "reset": {
                    "type": "boolean",
                    "description": "Specifies if previously-provided unseal keys are discarded and the unseal process is reset."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/wrapping/lookup": {
      "description": "Looks up the properties of a response-wrapped token.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Look up wrapping properties for the requester's token.",
        "operationId": "getSysWrappingLookup",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Look up wrapping properties for the given token.",
        "operationId": "postSysWrappingLookup",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/wrapping/rewrap": {
      "description": "Rotates a response-wrapped token.",
      "post": {
        "summary": "Rotates a response-wrapped token.",
        "operationId": "postSysWrappingRewrap",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/wrapping/unwrap": {
      "description": "Unwraps a response-wrapped token.",
      "post": {
        "summary": "Unwraps a response-wrapped token.",
        "operationId": "postSysWrappingUnwrap",
        "tags": [
          "system"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/wrapping/wrap": {
      "description": "Response-wraps an arbitrary JSON object.",
      "post": {
        "summary": "Response-wraps an arbitrary JSON object.",
        "operationId": "postSysWrappingWrap",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    }
  }
}
