Модуль выписки мульти пассов (особый jwt token) и jwt токенов

# Установка

Создайте объект контроллера, передав необходимые зависимости.
Api-пути получаются методом `controller.ApiPaths()` их необходимо тоже подключить.

Также необходимо вызывать `controller.OnPeriodic(tnx)` в функции `PeriodicFunc` бекэнда плагина, иначе
ротация приватных ключей работать НЕ БУДЕТ!
```
type PluginBackend struct {
  ...
  
  jwtController *jwt.Controller 
  
  ...    
}

    // где-то в инициализации
    b.jwtController = NewJwtController(storage, kafkaMb.GetEncryptionPublicKeyStrict, conf.Logger.Named("Module.Jwt"), time.Now)
    
    periodicFunction := func(ctx context.Context, request *logical.Request) error {
      ...
      tx := b.storage.Txn(true)
	  defer tx.Abort()

      err := b.jwtController.OnPeriodical(tx)
      if err != nil {
        // log error
        tx.Abort() 
      } else {
        if err := tx.Commit(); err != nil {
            // log error
		}      
      }  
      ...
    }
    
    b.Backend = &framework.Backend{
        ...
        
		PeriodicFunc: periodicFunction,
		Paths: framework.PathAppend(
		    ...
            b.jwtController.ApiPaths(),
            ...
		),
		...
```


# Принцип работы

Чтобы модуль заработал, необходимо его включить методом апи `jwt/enable`
и сконфигурировать с помощью метода `jwt/configure`

### Выписка токенов
Модуль создает себе приватный ключ (который хранится в self-очереди) и этим ключем может выписать следующие токены: 

`IssueMultipass()` - выписывает мультипасс, с помощью которого пользователь может залогинится.
Первоначальный токен с id=0 выписывает iam_auth при создание мультипасса сервис-аккаунта или пользователя
и отдается сразу же после создания. Продление токена производится auth-волтами 
методом апи `/issue/multipass_jwt/:multipass_uuid`. 
Сами токены мы нигде не храним, мы храним только лишь номер генерации токена
Если по какой-то причине мультипасс не дошел до пользователя, 
то пользователь (сервис-аккаунт) должен удалить мультипасс и сгенерить новый
В логине мы проверяем не только сигнатуру, но и существование мультипасса в базе 
и номер генерации токена (он же JTI) (хранится в TokenGenNumber очереди auth-волтов).
JTI это хеш от секрета мультипасса + номер. 
То есть, hash(текущий TokenGenNum мультипасса + соль мультипасса) == присланныйТокен.JTI 


`IssuePayloadAsJWT()` -  выписывает обычный JWT-токен с произвольным пайлоадом, 
который может проверить любой клиент с помощью JWKS, который, в свою очередь, может быть получен с помощью
метода api `/jwks` auth-волтов. Такие токены выписываются ТОЛЬКО auth-волтами 
в методе апи `/issue/jwt/:jwt_type_name`

### JWKS

Метод api `/jwks` отдает все ПУБЛИЧНЫЕ ключи со всех auth волтов + iam. О количестве ключей будет ниже
Данные ключи хранятся в очереди JWKS в которую могут писать, как auth так и iam волт (помним, он выписывает мультипасс)
Каждый волт публикует список ключей (да, список, ибо ротация) одним сообщением. 
Ключем сообщения является хеш от публичного ключа шифрования кафки. Для данной очереди включен **компекшн**, 
так как ключи мы периодически ротируем, и **ttl** так как auth-волт может быть удален 

### Ротация приватных ключей

Метод предусматривает переодическую ротацию приватных ключей. 
Она производится с периодом, указанным в rotation_period конфигурации, по умолчанию - 2 недели
Но ротация хитрая, с преанонсом нового публичного ключа. Рассмотрим пример.
- При включении модуля, сразу же генерируем приватный и публичный ключ. 
  Публичный ключ сразу аннонсируем в JWKS очередь. Записываем lastRotationTime
- в `PeriodicalFunc` бэкенда переодически вызывается метод `OnPeriodical` 
  которая производит следующие манипуляции:
  - как только `time.now > lastRotationTime + (conf.rotation_period - preliminary_announce_period)`
    т.е. со времени последней ротации прошло rotation_period минус preliminary_announce_period
    то мы генерируем новую связку приватного и публичного ключа (создание нового ключа). сохраняем их рядом. 
    В JWKS сразу же анонсируем новый публичный ключ. 
    Технически отправляем весь массив публичных ключей, которые у нас есть.
    Сразу оговоримся, то что в данном массиве может находится не более 3 ключей:
    - первый ключ - публичный ключ от приватного ключа, удаленного на предыдущей ротации.
      Зачем он нужен? Мы выписываем мультипассы на 2 недели. Поэтому мультипассы подписанные 
      уже удаленным предыдущим приватным ключ должны рабоать
    - второй ключ - публичный ключ от текущего приватного ключа. Nuff said.
    - третий ключ - публичный ключ от только что созданного ключ. Мы же его должны анонсировать, верно?
    В основной массе времени - в массиве будет два ключа - старый (удаленный) и текущий.
    Но между анонсом и ротации будет 3 ключа  
   
    НО для подписи продолжаем исользовать старый приватный ключ. 
    Технически мы храним список приватных ключей, поэтому старый лежит по индексу 0, а новый по индексу 1.
    В этом массиве у нас не может быть больше двух ключей
  -  как только `time.now > lastRotationTime + conf.rotation_period`
    мы удаляем старый приватный ключ (удаляем первый элемент массива)
    и мы удаляем протухший публичный ключ (он тоже будет первым в списке).
    Обновляем время последней ротации. Ну анонсируем текущие публичные ключи в очередь JWKS

Также есть возможность принудительной ротации ключей методом апи `jwt/rotate_key`.
Ротейт выполняется методом анологичным переодическим ротейтом, 
но без упреждающего анонсорования публичного ключа, то есть в jwks очереди какое-то 
время (несколько сотен мс) будет неполный список ключей.

### Выключение функционала.
Методом апи `jwt/enable`. Удаляет все приватные и публичные ключи и анонсирет данный факт через JWKS