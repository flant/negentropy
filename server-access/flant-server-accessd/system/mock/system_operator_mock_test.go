package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/flant/server-access/flintd/system.Interface -o ./mock/system_operator_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// InterfaceMock implements system.Interface
type InterfaceMock struct {
	t minimock.Tester

	funcBootUser          func(username string) (err error)
	inspectFuncBootUser   func(username string)
	afterBootUserCounter  uint64
	beforeBootUserCounter uint64
	BootUserMock          mInterfaceMockBootUser

	funcCreateHomeDir          func(dir string, uid int, gid int) (err error)
	inspectFuncCreateHomeDir   func(dir string, uid int, gid int)
	afterCreateHomeDirCounter  uint64
	beforeCreateHomeDirCounter uint64
	CreateHomeDirMock          mInterfaceMockCreateHomeDir

	funcDeleteHomeDir          func(dir string) (err error)
	inspectFuncDeleteHomeDir   func(dir string)
	afterDeleteHomeDirCounter  uint64
	beforeDeleteHomeDirCounter uint64
	DeleteHomeDirMock          mInterfaceMockDeleteHomeDir
}

// NewInterfaceMock returns a mock for system.Interface
func NewInterfaceMock(t minimock.Tester) *InterfaceMock {
	m := &InterfaceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BootUserMock = mInterfaceMockBootUser{mock: m}
	m.BootUserMock.callArgs = []*InterfaceMockBootUserParams{}

	m.CreateHomeDirMock = mInterfaceMockCreateHomeDir{mock: m}
	m.CreateHomeDirMock.callArgs = []*InterfaceMockCreateHomeDirParams{}

	m.DeleteHomeDirMock = mInterfaceMockDeleteHomeDir{mock: m}
	m.DeleteHomeDirMock.callArgs = []*InterfaceMockDeleteHomeDirParams{}

	return m
}

type mInterfaceMockBootUser struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockBootUserExpectation
	expectations       []*InterfaceMockBootUserExpectation

	callArgs []*InterfaceMockBootUserParams
	mutex    sync.RWMutex
}

// InterfaceMockBootUserExpectation specifies expectation struct of the Interface.BootUser
type InterfaceMockBootUserExpectation struct {
	mock    *InterfaceMock
	params  *InterfaceMockBootUserParams
	results *InterfaceMockBootUserResults
	Counter uint64
}

// InterfaceMockBootUserParams contains parameters of the Interface.BootUser
type InterfaceMockBootUserParams struct {
	username string
}

// InterfaceMockBootUserResults contains results of the Interface.BootUser
type InterfaceMockBootUserResults struct {
	err error
}

// Expect sets up expected params for Interface.BootUser
func (mmBootUser *mInterfaceMockBootUser) Expect(username string) *mInterfaceMockBootUser {
	if mmBootUser.mock.funcBootUser != nil {
		mmBootUser.mock.t.Fatalf("InterfaceMock.BootUser mock is already set by Set")
	}

	if mmBootUser.defaultExpectation == nil {
		mmBootUser.defaultExpectation = &InterfaceMockBootUserExpectation{}
	}

	mmBootUser.defaultExpectation.params = &InterfaceMockBootUserParams{username}
	for _, e := range mmBootUser.expectations {
		if minimock.Equal(e.params, mmBootUser.defaultExpectation.params) {
			mmBootUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBootUser.defaultExpectation.params)
		}
	}

	return mmBootUser
}

// Inspect accepts an inspector function that has same arguments as the Interface.BootUser
func (mmBootUser *mInterfaceMockBootUser) Inspect(f func(username string)) *mInterfaceMockBootUser {
	if mmBootUser.mock.inspectFuncBootUser != nil {
		mmBootUser.mock.t.Fatalf("Inspect function is already set for InterfaceMock.BootUser")
	}

	mmBootUser.mock.inspectFuncBootUser = f

	return mmBootUser
}

// Return sets up results that will be returned by Interface.BootUser
func (mmBootUser *mInterfaceMockBootUser) Return(err error) *InterfaceMock {
	if mmBootUser.mock.funcBootUser != nil {
		mmBootUser.mock.t.Fatalf("InterfaceMock.BootUser mock is already set by Set")
	}

	if mmBootUser.defaultExpectation == nil {
		mmBootUser.defaultExpectation = &InterfaceMockBootUserExpectation{mock: mmBootUser.mock}
	}
	mmBootUser.defaultExpectation.results = &InterfaceMockBootUserResults{err}
	return mmBootUser.mock
}

//Set uses given function f to mock the Interface.BootUser method
func (mmBootUser *mInterfaceMockBootUser) Set(f func(username string) (err error)) *InterfaceMock {
	if mmBootUser.defaultExpectation != nil {
		mmBootUser.mock.t.Fatalf("Default expectation is already set for the Interface.BootUser method")
	}

	if len(mmBootUser.expectations) > 0 {
		mmBootUser.mock.t.Fatalf("Some expectations are already set for the Interface.BootUser method")
	}

	mmBootUser.mock.funcBootUser = f
	return mmBootUser.mock
}

// When sets expectation for the Interface.BootUser which will trigger the result defined by the following
// Then helper
func (mmBootUser *mInterfaceMockBootUser) When(username string) *InterfaceMockBootUserExpectation {
	if mmBootUser.mock.funcBootUser != nil {
		mmBootUser.mock.t.Fatalf("InterfaceMock.BootUser mock is already set by Set")
	}

	expectation := &InterfaceMockBootUserExpectation{
		mock:   mmBootUser.mock,
		params: &InterfaceMockBootUserParams{username},
	}
	mmBootUser.expectations = append(mmBootUser.expectations, expectation)
	return expectation
}

// Then sets up Interface.BootUser return parameters for the expectation previously defined by the When method
func (e *InterfaceMockBootUserExpectation) Then(err error) *InterfaceMock {
	e.results = &InterfaceMockBootUserResults{err}
	return e.mock
}

// BootUser implements system.Interface
func (mmBootUser *InterfaceMock) BootUser(username string) (err error) {
	mm_atomic.AddUint64(&mmBootUser.beforeBootUserCounter, 1)
	defer mm_atomic.AddUint64(&mmBootUser.afterBootUserCounter, 1)

	if mmBootUser.inspectFuncBootUser != nil {
		mmBootUser.inspectFuncBootUser(username)
	}

	mm_params := &InterfaceMockBootUserParams{username}

	// Record call args
	mmBootUser.BootUserMock.mutex.Lock()
	mmBootUser.BootUserMock.callArgs = append(mmBootUser.BootUserMock.callArgs, mm_params)
	mmBootUser.BootUserMock.mutex.Unlock()

	for _, e := range mmBootUser.BootUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBootUser.BootUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBootUser.BootUserMock.defaultExpectation.Counter, 1)
		mm_want := mmBootUser.BootUserMock.defaultExpectation.params
		mm_got := InterfaceMockBootUserParams{username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBootUser.t.Errorf("InterfaceMock.BootUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBootUser.BootUserMock.defaultExpectation.results
		if mm_results == nil {
			mmBootUser.t.Fatal("No results are set for the InterfaceMock.BootUser")
		}
		return (*mm_results).err
	}
	if mmBootUser.funcBootUser != nil {
		return mmBootUser.funcBootUser(username)
	}
	mmBootUser.t.Fatalf("Unexpected call to InterfaceMock.BootUser. %v", username)
	return
}

// BootUserAfterCounter returns a count of finished InterfaceMock.BootUser invocations
func (mmBootUser *InterfaceMock) BootUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBootUser.afterBootUserCounter)
}

// BootUserBeforeCounter returns a count of InterfaceMock.BootUser invocations
func (mmBootUser *InterfaceMock) BootUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBootUser.beforeBootUserCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.BootUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBootUser *mInterfaceMockBootUser) Calls() []*InterfaceMockBootUserParams {
	mmBootUser.mutex.RLock()

	argCopy := make([]*InterfaceMockBootUserParams, len(mmBootUser.callArgs))
	copy(argCopy, mmBootUser.callArgs)

	mmBootUser.mutex.RUnlock()

	return argCopy
}

// MinimockBootUserDone returns true if the count of the BootUser invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockBootUserDone() bool {
	for _, e := range m.BootUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BootUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBootUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBootUser != nil && mm_atomic.LoadUint64(&m.afterBootUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockBootUserInspect logs each unmet expectation
func (m *InterfaceMock) MinimockBootUserInspect() {
	for _, e := range m.BootUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.BootUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BootUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBootUserCounter) < 1 {
		if m.BootUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.BootUser")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.BootUser with params: %#v", *m.BootUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBootUser != nil && mm_atomic.LoadUint64(&m.afterBootUserCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.BootUser")
	}
}

type mInterfaceMockCreateHomeDir struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockCreateHomeDirExpectation
	expectations       []*InterfaceMockCreateHomeDirExpectation

	callArgs []*InterfaceMockCreateHomeDirParams
	mutex    sync.RWMutex
}

// InterfaceMockCreateHomeDirExpectation specifies expectation struct of the Interface.CreateHomeDir
type InterfaceMockCreateHomeDirExpectation struct {
	mock    *InterfaceMock
	params  *InterfaceMockCreateHomeDirParams
	results *InterfaceMockCreateHomeDirResults
	Counter uint64
}

// InterfaceMockCreateHomeDirParams contains parameters of the Interface.CreateHomeDir
type InterfaceMockCreateHomeDirParams struct {
	dir string
	uid int
	gid int
}

// InterfaceMockCreateHomeDirResults contains results of the Interface.CreateHomeDir
type InterfaceMockCreateHomeDirResults struct {
	err error
}

// Expect sets up expected params for Interface.CreateHomeDir
func (mmCreateHomeDir *mInterfaceMockCreateHomeDir) Expect(dir string, uid int, gid int) *mInterfaceMockCreateHomeDir {
	if mmCreateHomeDir.mock.funcCreateHomeDir != nil {
		mmCreateHomeDir.mock.t.Fatalf("InterfaceMock.CreateHomeDir mock is already set by Set")
	}

	if mmCreateHomeDir.defaultExpectation == nil {
		mmCreateHomeDir.defaultExpectation = &InterfaceMockCreateHomeDirExpectation{}
	}

	mmCreateHomeDir.defaultExpectation.params = &InterfaceMockCreateHomeDirParams{dir, uid, gid}
	for _, e := range mmCreateHomeDir.expectations {
		if minimock.Equal(e.params, mmCreateHomeDir.defaultExpectation.params) {
			mmCreateHomeDir.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateHomeDir.defaultExpectation.params)
		}
	}

	return mmCreateHomeDir
}

// Inspect accepts an inspector function that has same arguments as the Interface.CreateHomeDir
func (mmCreateHomeDir *mInterfaceMockCreateHomeDir) Inspect(f func(dir string, uid int, gid int)) *mInterfaceMockCreateHomeDir {
	if mmCreateHomeDir.mock.inspectFuncCreateHomeDir != nil {
		mmCreateHomeDir.mock.t.Fatalf("Inspect function is already set for InterfaceMock.CreateHomeDir")
	}

	mmCreateHomeDir.mock.inspectFuncCreateHomeDir = f

	return mmCreateHomeDir
}

// Return sets up results that will be returned by Interface.CreateHomeDir
func (mmCreateHomeDir *mInterfaceMockCreateHomeDir) Return(err error) *InterfaceMock {
	if mmCreateHomeDir.mock.funcCreateHomeDir != nil {
		mmCreateHomeDir.mock.t.Fatalf("InterfaceMock.CreateHomeDir mock is already set by Set")
	}

	if mmCreateHomeDir.defaultExpectation == nil {
		mmCreateHomeDir.defaultExpectation = &InterfaceMockCreateHomeDirExpectation{mock: mmCreateHomeDir.mock}
	}
	mmCreateHomeDir.defaultExpectation.results = &InterfaceMockCreateHomeDirResults{err}
	return mmCreateHomeDir.mock
}

//Set uses given function f to mock the Interface.CreateHomeDir method
func (mmCreateHomeDir *mInterfaceMockCreateHomeDir) Set(f func(dir string, uid int, gid int) (err error)) *InterfaceMock {
	if mmCreateHomeDir.defaultExpectation != nil {
		mmCreateHomeDir.mock.t.Fatalf("Default expectation is already set for the Interface.CreateHomeDir method")
	}

	if len(mmCreateHomeDir.expectations) > 0 {
		mmCreateHomeDir.mock.t.Fatalf("Some expectations are already set for the Interface.CreateHomeDir method")
	}

	mmCreateHomeDir.mock.funcCreateHomeDir = f
	return mmCreateHomeDir.mock
}

// When sets expectation for the Interface.CreateHomeDir which will trigger the result defined by the following
// Then helper
func (mmCreateHomeDir *mInterfaceMockCreateHomeDir) When(dir string, uid int, gid int) *InterfaceMockCreateHomeDirExpectation {
	if mmCreateHomeDir.mock.funcCreateHomeDir != nil {
		mmCreateHomeDir.mock.t.Fatalf("InterfaceMock.CreateHomeDir mock is already set by Set")
	}

	expectation := &InterfaceMockCreateHomeDirExpectation{
		mock:   mmCreateHomeDir.mock,
		params: &InterfaceMockCreateHomeDirParams{dir, uid, gid},
	}
	mmCreateHomeDir.expectations = append(mmCreateHomeDir.expectations, expectation)
	return expectation
}

// Then sets up Interface.CreateHomeDir return parameters for the expectation previously defined by the When method
func (e *InterfaceMockCreateHomeDirExpectation) Then(err error) *InterfaceMock {
	e.results = &InterfaceMockCreateHomeDirResults{err}
	return e.mock
}

// CreateHomeDir implements system.Interface
func (mmCreateHomeDir *InterfaceMock) CreateHomeDir(dir string, uid int, gid int) (err error) {
	mm_atomic.AddUint64(&mmCreateHomeDir.beforeCreateHomeDirCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateHomeDir.afterCreateHomeDirCounter, 1)

	if mmCreateHomeDir.inspectFuncCreateHomeDir != nil {
		mmCreateHomeDir.inspectFuncCreateHomeDir(dir, uid, gid)
	}

	mm_params := &InterfaceMockCreateHomeDirParams{dir, uid, gid}

	// Record call args
	mmCreateHomeDir.CreateHomeDirMock.mutex.Lock()
	mmCreateHomeDir.CreateHomeDirMock.callArgs = append(mmCreateHomeDir.CreateHomeDirMock.callArgs, mm_params)
	mmCreateHomeDir.CreateHomeDirMock.mutex.Unlock()

	for _, e := range mmCreateHomeDir.CreateHomeDirMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateHomeDir.CreateHomeDirMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateHomeDir.CreateHomeDirMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateHomeDir.CreateHomeDirMock.defaultExpectation.params
		mm_got := InterfaceMockCreateHomeDirParams{dir, uid, gid}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateHomeDir.t.Errorf("InterfaceMock.CreateHomeDir got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateHomeDir.CreateHomeDirMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateHomeDir.t.Fatal("No results are set for the InterfaceMock.CreateHomeDir")
		}
		return (*mm_results).err
	}
	if mmCreateHomeDir.funcCreateHomeDir != nil {
		return mmCreateHomeDir.funcCreateHomeDir(dir, uid, gid)
	}
	mmCreateHomeDir.t.Fatalf("Unexpected call to InterfaceMock.CreateHomeDir. %v %v %v", dir, uid, gid)
	return
}

// CreateHomeDirAfterCounter returns a count of finished InterfaceMock.CreateHomeDir invocations
func (mmCreateHomeDir *InterfaceMock) CreateHomeDirAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateHomeDir.afterCreateHomeDirCounter)
}

// CreateHomeDirBeforeCounter returns a count of InterfaceMock.CreateHomeDir invocations
func (mmCreateHomeDir *InterfaceMock) CreateHomeDirBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateHomeDir.beforeCreateHomeDirCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.CreateHomeDir.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateHomeDir *mInterfaceMockCreateHomeDir) Calls() []*InterfaceMockCreateHomeDirParams {
	mmCreateHomeDir.mutex.RLock()

	argCopy := make([]*InterfaceMockCreateHomeDirParams, len(mmCreateHomeDir.callArgs))
	copy(argCopy, mmCreateHomeDir.callArgs)

	mmCreateHomeDir.mutex.RUnlock()

	return argCopy
}

// MinimockCreateHomeDirDone returns true if the count of the CreateHomeDir invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockCreateHomeDirDone() bool {
	for _, e := range m.CreateHomeDirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateHomeDirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateHomeDirCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateHomeDir != nil && mm_atomic.LoadUint64(&m.afterCreateHomeDirCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateHomeDirInspect logs each unmet expectation
func (m *InterfaceMock) MinimockCreateHomeDirInspect() {
	for _, e := range m.CreateHomeDirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.CreateHomeDir with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateHomeDirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateHomeDirCounter) < 1 {
		if m.CreateHomeDirMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.CreateHomeDir")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.CreateHomeDir with params: %#v", *m.CreateHomeDirMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateHomeDir != nil && mm_atomic.LoadUint64(&m.afterCreateHomeDirCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.CreateHomeDir")
	}
}

type mInterfaceMockDeleteHomeDir struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockDeleteHomeDirExpectation
	expectations       []*InterfaceMockDeleteHomeDirExpectation

	callArgs []*InterfaceMockDeleteHomeDirParams
	mutex    sync.RWMutex
}

// InterfaceMockDeleteHomeDirExpectation specifies expectation struct of the Interface.DeleteHomeDir
type InterfaceMockDeleteHomeDirExpectation struct {
	mock    *InterfaceMock
	params  *InterfaceMockDeleteHomeDirParams
	results *InterfaceMockDeleteHomeDirResults
	Counter uint64
}

// InterfaceMockDeleteHomeDirParams contains parameters of the Interface.DeleteHomeDir
type InterfaceMockDeleteHomeDirParams struct {
	dir string
}

// InterfaceMockDeleteHomeDirResults contains results of the Interface.DeleteHomeDir
type InterfaceMockDeleteHomeDirResults struct {
	err error
}

// Expect sets up expected params for Interface.DeleteHomeDir
func (mmDeleteHomeDir *mInterfaceMockDeleteHomeDir) Expect(dir string) *mInterfaceMockDeleteHomeDir {
	if mmDeleteHomeDir.mock.funcDeleteHomeDir != nil {
		mmDeleteHomeDir.mock.t.Fatalf("InterfaceMock.DeleteHomeDir mock is already set by Set")
	}

	if mmDeleteHomeDir.defaultExpectation == nil {
		mmDeleteHomeDir.defaultExpectation = &InterfaceMockDeleteHomeDirExpectation{}
	}

	mmDeleteHomeDir.defaultExpectation.params = &InterfaceMockDeleteHomeDirParams{dir}
	for _, e := range mmDeleteHomeDir.expectations {
		if minimock.Equal(e.params, mmDeleteHomeDir.defaultExpectation.params) {
			mmDeleteHomeDir.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteHomeDir.defaultExpectation.params)
		}
	}

	return mmDeleteHomeDir
}

// Inspect accepts an inspector function that has same arguments as the Interface.DeleteHomeDir
func (mmDeleteHomeDir *mInterfaceMockDeleteHomeDir) Inspect(f func(dir string)) *mInterfaceMockDeleteHomeDir {
	if mmDeleteHomeDir.mock.inspectFuncDeleteHomeDir != nil {
		mmDeleteHomeDir.mock.t.Fatalf("Inspect function is already set for InterfaceMock.DeleteHomeDir")
	}

	mmDeleteHomeDir.mock.inspectFuncDeleteHomeDir = f

	return mmDeleteHomeDir
}

// Return sets up results that will be returned by Interface.DeleteHomeDir
func (mmDeleteHomeDir *mInterfaceMockDeleteHomeDir) Return(err error) *InterfaceMock {
	if mmDeleteHomeDir.mock.funcDeleteHomeDir != nil {
		mmDeleteHomeDir.mock.t.Fatalf("InterfaceMock.DeleteHomeDir mock is already set by Set")
	}

	if mmDeleteHomeDir.defaultExpectation == nil {
		mmDeleteHomeDir.defaultExpectation = &InterfaceMockDeleteHomeDirExpectation{mock: mmDeleteHomeDir.mock}
	}
	mmDeleteHomeDir.defaultExpectation.results = &InterfaceMockDeleteHomeDirResults{err}
	return mmDeleteHomeDir.mock
}

//Set uses given function f to mock the Interface.DeleteHomeDir method
func (mmDeleteHomeDir *mInterfaceMockDeleteHomeDir) Set(f func(dir string) (err error)) *InterfaceMock {
	if mmDeleteHomeDir.defaultExpectation != nil {
		mmDeleteHomeDir.mock.t.Fatalf("Default expectation is already set for the Interface.DeleteHomeDir method")
	}

	if len(mmDeleteHomeDir.expectations) > 0 {
		mmDeleteHomeDir.mock.t.Fatalf("Some expectations are already set for the Interface.DeleteHomeDir method")
	}

	mmDeleteHomeDir.mock.funcDeleteHomeDir = f
	return mmDeleteHomeDir.mock
}

// When sets expectation for the Interface.DeleteHomeDir which will trigger the result defined by the following
// Then helper
func (mmDeleteHomeDir *mInterfaceMockDeleteHomeDir) When(dir string) *InterfaceMockDeleteHomeDirExpectation {
	if mmDeleteHomeDir.mock.funcDeleteHomeDir != nil {
		mmDeleteHomeDir.mock.t.Fatalf("InterfaceMock.DeleteHomeDir mock is already set by Set")
	}

	expectation := &InterfaceMockDeleteHomeDirExpectation{
		mock:   mmDeleteHomeDir.mock,
		params: &InterfaceMockDeleteHomeDirParams{dir},
	}
	mmDeleteHomeDir.expectations = append(mmDeleteHomeDir.expectations, expectation)
	return expectation
}

// Then sets up Interface.DeleteHomeDir return parameters for the expectation previously defined by the When method
func (e *InterfaceMockDeleteHomeDirExpectation) Then(err error) *InterfaceMock {
	e.results = &InterfaceMockDeleteHomeDirResults{err}
	return e.mock
}

// DeleteHomeDir implements system.Interface
func (mmDeleteHomeDir *InterfaceMock) DeleteHomeDir(dir string) (err error) {
	mm_atomic.AddUint64(&mmDeleteHomeDir.beforeDeleteHomeDirCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteHomeDir.afterDeleteHomeDirCounter, 1)

	if mmDeleteHomeDir.inspectFuncDeleteHomeDir != nil {
		mmDeleteHomeDir.inspectFuncDeleteHomeDir(dir)
	}

	mm_params := &InterfaceMockDeleteHomeDirParams{dir}

	// Record call args
	mmDeleteHomeDir.DeleteHomeDirMock.mutex.Lock()
	mmDeleteHomeDir.DeleteHomeDirMock.callArgs = append(mmDeleteHomeDir.DeleteHomeDirMock.callArgs, mm_params)
	mmDeleteHomeDir.DeleteHomeDirMock.mutex.Unlock()

	for _, e := range mmDeleteHomeDir.DeleteHomeDirMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteHomeDir.DeleteHomeDirMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteHomeDir.DeleteHomeDirMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteHomeDir.DeleteHomeDirMock.defaultExpectation.params
		mm_got := InterfaceMockDeleteHomeDirParams{dir}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteHomeDir.t.Errorf("InterfaceMock.DeleteHomeDir got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteHomeDir.DeleteHomeDirMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteHomeDir.t.Fatal("No results are set for the InterfaceMock.DeleteHomeDir")
		}
		return (*mm_results).err
	}
	if mmDeleteHomeDir.funcDeleteHomeDir != nil {
		return mmDeleteHomeDir.funcDeleteHomeDir(dir)
	}
	mmDeleteHomeDir.t.Fatalf("Unexpected call to InterfaceMock.DeleteHomeDir. %v", dir)
	return
}

// DeleteHomeDirAfterCounter returns a count of finished InterfaceMock.DeleteHomeDir invocations
func (mmDeleteHomeDir *InterfaceMock) DeleteHomeDirAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteHomeDir.afterDeleteHomeDirCounter)
}

// DeleteHomeDirBeforeCounter returns a count of InterfaceMock.DeleteHomeDir invocations
func (mmDeleteHomeDir *InterfaceMock) DeleteHomeDirBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteHomeDir.beforeDeleteHomeDirCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.DeleteHomeDir.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteHomeDir *mInterfaceMockDeleteHomeDir) Calls() []*InterfaceMockDeleteHomeDirParams {
	mmDeleteHomeDir.mutex.RLock()

	argCopy := make([]*InterfaceMockDeleteHomeDirParams, len(mmDeleteHomeDir.callArgs))
	copy(argCopy, mmDeleteHomeDir.callArgs)

	mmDeleteHomeDir.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteHomeDirDone returns true if the count of the DeleteHomeDir invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockDeleteHomeDirDone() bool {
	for _, e := range m.DeleteHomeDirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteHomeDirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteHomeDirCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteHomeDir != nil && mm_atomic.LoadUint64(&m.afterDeleteHomeDirCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteHomeDirInspect logs each unmet expectation
func (m *InterfaceMock) MinimockDeleteHomeDirInspect() {
	for _, e := range m.DeleteHomeDirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.DeleteHomeDir with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteHomeDirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteHomeDirCounter) < 1 {
		if m.DeleteHomeDirMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.DeleteHomeDir")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.DeleteHomeDir with params: %#v", *m.DeleteHomeDirMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteHomeDir != nil && mm_atomic.LoadUint64(&m.afterDeleteHomeDirCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.DeleteHomeDir")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *InterfaceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBootUserInspect()

		m.MinimockCreateHomeDirInspect()

		m.MinimockDeleteHomeDirInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *InterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *InterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBootUserDone() &&
		m.MinimockCreateHomeDirDone() &&
		m.MinimockDeleteHomeDirDone()
}
