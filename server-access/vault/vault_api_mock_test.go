package vault

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/flant/server-access/vault.Logical -o ./vault_api_mock.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/hashicorp/vault/api"
)

// LogicalMock implements Logical
type LogicalMock struct {
	t minimock.Tester

	funcDelete          func(path string) (sp1 *api.Secret, err error)
	inspectFuncDelete   func(path string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mLogicalMockDelete

	funcDeleteWithData          func(path string, data map[string][]string) (sp1 *api.Secret, err error)
	inspectFuncDeleteWithData   func(path string, data map[string][]string)
	afterDeleteWithDataCounter  uint64
	beforeDeleteWithDataCounter uint64
	DeleteWithDataMock          mLogicalMockDeleteWithData

	funcList          func(path string) (sp1 *api.Secret, err error)
	inspectFuncList   func(path string)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mLogicalMockList

	funcRead          func(path string) (sp1 *api.Secret, err error)
	inspectFuncRead   func(path string)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mLogicalMockRead

	funcReadWithData          func(path string, data map[string][]string) (sp1 *api.Secret, err error)
	inspectFuncReadWithData   func(path string, data map[string][]string)
	afterReadWithDataCounter  uint64
	beforeReadWithDataCounter uint64
	ReadWithDataMock          mLogicalMockReadWithData

	funcUnwrap          func(wrappingToken string) (sp1 *api.Secret, err error)
	inspectFuncUnwrap   func(wrappingToken string)
	afterUnwrapCounter  uint64
	beforeUnwrapCounter uint64
	UnwrapMock          mLogicalMockUnwrap

	funcWrite          func(path string, data map[string]interface{}) (sp1 *api.Secret, err error)
	inspectFuncWrite   func(path string, data map[string]interface{})
	afterWriteCounter  uint64
	beforeWriteCounter uint64
	WriteMock          mLogicalMockWrite

	funcWriteBytes          func(path string, data []byte) (sp1 *api.Secret, err error)
	inspectFuncWriteBytes   func(path string, data []byte)
	afterWriteBytesCounter  uint64
	beforeWriteBytesCounter uint64
	WriteBytesMock          mLogicalMockWriteBytes
}

// NewLogicalMock returns a mock for Logical
func NewLogicalMock(t minimock.Tester) *LogicalMock {
	m := &LogicalMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mLogicalMockDelete{mock: m}
	m.DeleteMock.callArgs = []*LogicalMockDeleteParams{}

	m.DeleteWithDataMock = mLogicalMockDeleteWithData{mock: m}
	m.DeleteWithDataMock.callArgs = []*LogicalMockDeleteWithDataParams{}

	m.ListMock = mLogicalMockList{mock: m}
	m.ListMock.callArgs = []*LogicalMockListParams{}

	m.ReadMock = mLogicalMockRead{mock: m}
	m.ReadMock.callArgs = []*LogicalMockReadParams{}

	m.ReadWithDataMock = mLogicalMockReadWithData{mock: m}
	m.ReadWithDataMock.callArgs = []*LogicalMockReadWithDataParams{}

	m.UnwrapMock = mLogicalMockUnwrap{mock: m}
	m.UnwrapMock.callArgs = []*LogicalMockUnwrapParams{}

	m.WriteMock = mLogicalMockWrite{mock: m}
	m.WriteMock.callArgs = []*LogicalMockWriteParams{}

	m.WriteBytesMock = mLogicalMockWriteBytes{mock: m}
	m.WriteBytesMock.callArgs = []*LogicalMockWriteBytesParams{}

	return m
}

type mLogicalMockDelete struct {
	mock               *LogicalMock
	defaultExpectation *LogicalMockDeleteExpectation
	expectations       []*LogicalMockDeleteExpectation

	callArgs []*LogicalMockDeleteParams
	mutex    sync.RWMutex
}

// LogicalMockDeleteExpectation specifies expectation struct of the Logical.Delete
type LogicalMockDeleteExpectation struct {
	mock    *LogicalMock
	params  *LogicalMockDeleteParams
	results *LogicalMockDeleteResults
	Counter uint64
}

// LogicalMockDeleteParams contains parameters of the Logical.Delete
type LogicalMockDeleteParams struct {
	path string
}

// LogicalMockDeleteResults contains results of the Logical.Delete
type LogicalMockDeleteResults struct {
	sp1 *api.Secret
	err error
}

// Expect sets up expected params for Logical.Delete
func (mmDelete *mLogicalMockDelete) Expect(path string) *mLogicalMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("LogicalMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &LogicalMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &LogicalMockDeleteParams{path}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Logical.Delete
func (mmDelete *mLogicalMockDelete) Inspect(f func(path string)) *mLogicalMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for LogicalMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Logical.Delete
func (mmDelete *mLogicalMockDelete) Return(sp1 *api.Secret, err error) *LogicalMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("LogicalMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &LogicalMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &LogicalMockDeleteResults{sp1, err}
	return mmDelete.mock
}

//Set uses given function f to mock the Logical.Delete method
func (mmDelete *mLogicalMockDelete) Set(f func(path string) (sp1 *api.Secret, err error)) *LogicalMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Logical.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Logical.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Logical.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mLogicalMockDelete) When(path string) *LogicalMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("LogicalMock.Delete mock is already set by Set")
	}

	expectation := &LogicalMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &LogicalMockDeleteParams{path},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Logical.Delete return parameters for the expectation previously defined by the When method
func (e *LogicalMockDeleteExpectation) Then(sp1 *api.Secret, err error) *LogicalMock {
	e.results = &LogicalMockDeleteResults{sp1, err}
	return e.mock
}

// Delete implements Logical
func (mmDelete *LogicalMock) Delete(path string) (sp1 *api.Secret, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(path)
	}

	mm_params := &LogicalMockDeleteParams{path}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := LogicalMockDeleteParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("LogicalMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the LogicalMock.Delete")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(path)
	}
	mmDelete.t.Fatalf("Unexpected call to LogicalMock.Delete. %v", path)
	return
}

// DeleteAfterCounter returns a count of finished LogicalMock.Delete invocations
func (mmDelete *LogicalMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of LogicalMock.Delete invocations
func (mmDelete *LogicalMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to LogicalMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mLogicalMockDelete) Calls() []*LogicalMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*LogicalMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *LogicalMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *LogicalMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogicalMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogicalMock.Delete")
		} else {
			m.t.Errorf("Expected call to LogicalMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to LogicalMock.Delete")
	}
}

type mLogicalMockDeleteWithData struct {
	mock               *LogicalMock
	defaultExpectation *LogicalMockDeleteWithDataExpectation
	expectations       []*LogicalMockDeleteWithDataExpectation

	callArgs []*LogicalMockDeleteWithDataParams
	mutex    sync.RWMutex
}

// LogicalMockDeleteWithDataExpectation specifies expectation struct of the Logical.DeleteWithData
type LogicalMockDeleteWithDataExpectation struct {
	mock    *LogicalMock
	params  *LogicalMockDeleteWithDataParams
	results *LogicalMockDeleteWithDataResults
	Counter uint64
}

// LogicalMockDeleteWithDataParams contains parameters of the Logical.DeleteWithData
type LogicalMockDeleteWithDataParams struct {
	path string
	data map[string][]string
}

// LogicalMockDeleteWithDataResults contains results of the Logical.DeleteWithData
type LogicalMockDeleteWithDataResults struct {
	sp1 *api.Secret
	err error
}

// Expect sets up expected params for Logical.DeleteWithData
func (mmDeleteWithData *mLogicalMockDeleteWithData) Expect(path string, data map[string][]string) *mLogicalMockDeleteWithData {
	if mmDeleteWithData.mock.funcDeleteWithData != nil {
		mmDeleteWithData.mock.t.Fatalf("LogicalMock.DeleteWithData mock is already set by Set")
	}

	if mmDeleteWithData.defaultExpectation == nil {
		mmDeleteWithData.defaultExpectation = &LogicalMockDeleteWithDataExpectation{}
	}

	mmDeleteWithData.defaultExpectation.params = &LogicalMockDeleteWithDataParams{path, data}
	for _, e := range mmDeleteWithData.expectations {
		if minimock.Equal(e.params, mmDeleteWithData.defaultExpectation.params) {
			mmDeleteWithData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteWithData.defaultExpectation.params)
		}
	}

	return mmDeleteWithData
}

// Inspect accepts an inspector function that has same arguments as the Logical.DeleteWithData
func (mmDeleteWithData *mLogicalMockDeleteWithData) Inspect(f func(path string, data map[string][]string)) *mLogicalMockDeleteWithData {
	if mmDeleteWithData.mock.inspectFuncDeleteWithData != nil {
		mmDeleteWithData.mock.t.Fatalf("Inspect function is already set for LogicalMock.DeleteWithData")
	}

	mmDeleteWithData.mock.inspectFuncDeleteWithData = f

	return mmDeleteWithData
}

// Return sets up results that will be returned by Logical.DeleteWithData
func (mmDeleteWithData *mLogicalMockDeleteWithData) Return(sp1 *api.Secret, err error) *LogicalMock {
	if mmDeleteWithData.mock.funcDeleteWithData != nil {
		mmDeleteWithData.mock.t.Fatalf("LogicalMock.DeleteWithData mock is already set by Set")
	}

	if mmDeleteWithData.defaultExpectation == nil {
		mmDeleteWithData.defaultExpectation = &LogicalMockDeleteWithDataExpectation{mock: mmDeleteWithData.mock}
	}
	mmDeleteWithData.defaultExpectation.results = &LogicalMockDeleteWithDataResults{sp1, err}
	return mmDeleteWithData.mock
}

//Set uses given function f to mock the Logical.DeleteWithData method
func (mmDeleteWithData *mLogicalMockDeleteWithData) Set(f func(path string, data map[string][]string) (sp1 *api.Secret, err error)) *LogicalMock {
	if mmDeleteWithData.defaultExpectation != nil {
		mmDeleteWithData.mock.t.Fatalf("Default expectation is already set for the Logical.DeleteWithData method")
	}

	if len(mmDeleteWithData.expectations) > 0 {
		mmDeleteWithData.mock.t.Fatalf("Some expectations are already set for the Logical.DeleteWithData method")
	}

	mmDeleteWithData.mock.funcDeleteWithData = f
	return mmDeleteWithData.mock
}

// When sets expectation for the Logical.DeleteWithData which will trigger the result defined by the following
// Then helper
func (mmDeleteWithData *mLogicalMockDeleteWithData) When(path string, data map[string][]string) *LogicalMockDeleteWithDataExpectation {
	if mmDeleteWithData.mock.funcDeleteWithData != nil {
		mmDeleteWithData.mock.t.Fatalf("LogicalMock.DeleteWithData mock is already set by Set")
	}

	expectation := &LogicalMockDeleteWithDataExpectation{
		mock:   mmDeleteWithData.mock,
		params: &LogicalMockDeleteWithDataParams{path, data},
	}
	mmDeleteWithData.expectations = append(mmDeleteWithData.expectations, expectation)
	return expectation
}

// Then sets up Logical.DeleteWithData return parameters for the expectation previously defined by the When method
func (e *LogicalMockDeleteWithDataExpectation) Then(sp1 *api.Secret, err error) *LogicalMock {
	e.results = &LogicalMockDeleteWithDataResults{sp1, err}
	return e.mock
}

// DeleteWithData implements Logical
func (mmDeleteWithData *LogicalMock) DeleteWithData(path string, data map[string][]string) (sp1 *api.Secret, err error) {
	mm_atomic.AddUint64(&mmDeleteWithData.beforeDeleteWithDataCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteWithData.afterDeleteWithDataCounter, 1)

	if mmDeleteWithData.inspectFuncDeleteWithData != nil {
		mmDeleteWithData.inspectFuncDeleteWithData(path, data)
	}

	mm_params := &LogicalMockDeleteWithDataParams{path, data}

	// Record call args
	mmDeleteWithData.DeleteWithDataMock.mutex.Lock()
	mmDeleteWithData.DeleteWithDataMock.callArgs = append(mmDeleteWithData.DeleteWithDataMock.callArgs, mm_params)
	mmDeleteWithData.DeleteWithDataMock.mutex.Unlock()

	for _, e := range mmDeleteWithData.DeleteWithDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmDeleteWithData.DeleteWithDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteWithData.DeleteWithDataMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteWithData.DeleteWithDataMock.defaultExpectation.params
		mm_got := LogicalMockDeleteWithDataParams{path, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteWithData.t.Errorf("LogicalMock.DeleteWithData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteWithData.DeleteWithDataMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteWithData.t.Fatal("No results are set for the LogicalMock.DeleteWithData")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmDeleteWithData.funcDeleteWithData != nil {
		return mmDeleteWithData.funcDeleteWithData(path, data)
	}
	mmDeleteWithData.t.Fatalf("Unexpected call to LogicalMock.DeleteWithData. %v %v", path, data)
	return
}

// DeleteWithDataAfterCounter returns a count of finished LogicalMock.DeleteWithData invocations
func (mmDeleteWithData *LogicalMock) DeleteWithDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteWithData.afterDeleteWithDataCounter)
}

// DeleteWithDataBeforeCounter returns a count of LogicalMock.DeleteWithData invocations
func (mmDeleteWithData *LogicalMock) DeleteWithDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteWithData.beforeDeleteWithDataCounter)
}

// Calls returns a list of arguments used in each call to LogicalMock.DeleteWithData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteWithData *mLogicalMockDeleteWithData) Calls() []*LogicalMockDeleteWithDataParams {
	mmDeleteWithData.mutex.RLock()

	argCopy := make([]*LogicalMockDeleteWithDataParams, len(mmDeleteWithData.callArgs))
	copy(argCopy, mmDeleteWithData.callArgs)

	mmDeleteWithData.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteWithDataDone returns true if the count of the DeleteWithData invocations corresponds
// the number of defined expectations
func (m *LogicalMock) MinimockDeleteWithDataDone() bool {
	for _, e := range m.DeleteWithDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteWithDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteWithDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteWithData != nil && mm_atomic.LoadUint64(&m.afterDeleteWithDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteWithDataInspect logs each unmet expectation
func (m *LogicalMock) MinimockDeleteWithDataInspect() {
	for _, e := range m.DeleteWithDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogicalMock.DeleteWithData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteWithDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteWithDataCounter) < 1 {
		if m.DeleteWithDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogicalMock.DeleteWithData")
		} else {
			m.t.Errorf("Expected call to LogicalMock.DeleteWithData with params: %#v", *m.DeleteWithDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteWithData != nil && mm_atomic.LoadUint64(&m.afterDeleteWithDataCounter) < 1 {
		m.t.Error("Expected call to LogicalMock.DeleteWithData")
	}
}

type mLogicalMockList struct {
	mock               *LogicalMock
	defaultExpectation *LogicalMockListExpectation
	expectations       []*LogicalMockListExpectation

	callArgs []*LogicalMockListParams
	mutex    sync.RWMutex
}

// LogicalMockListExpectation specifies expectation struct of the Logical.List
type LogicalMockListExpectation struct {
	mock    *LogicalMock
	params  *LogicalMockListParams
	results *LogicalMockListResults
	Counter uint64
}

// LogicalMockListParams contains parameters of the Logical.List
type LogicalMockListParams struct {
	path string
}

// LogicalMockListResults contains results of the Logical.List
type LogicalMockListResults struct {
	sp1 *api.Secret
	err error
}

// Expect sets up expected params for Logical.List
func (mmList *mLogicalMockList) Expect(path string) *mLogicalMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("LogicalMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &LogicalMockListExpectation{}
	}

	mmList.defaultExpectation.params = &LogicalMockListParams{path}
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the Logical.List
func (mmList *mLogicalMockList) Inspect(f func(path string)) *mLogicalMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for LogicalMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by Logical.List
func (mmList *mLogicalMockList) Return(sp1 *api.Secret, err error) *LogicalMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("LogicalMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &LogicalMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &LogicalMockListResults{sp1, err}
	return mmList.mock
}

//Set uses given function f to mock the Logical.List method
func (mmList *mLogicalMockList) Set(f func(path string) (sp1 *api.Secret, err error)) *LogicalMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the Logical.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the Logical.List method")
	}

	mmList.mock.funcList = f
	return mmList.mock
}

// When sets expectation for the Logical.List which will trigger the result defined by the following
// Then helper
func (mmList *mLogicalMockList) When(path string) *LogicalMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("LogicalMock.List mock is already set by Set")
	}

	expectation := &LogicalMockListExpectation{
		mock:   mmList.mock,
		params: &LogicalMockListParams{path},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up Logical.List return parameters for the expectation previously defined by the When method
func (e *LogicalMockListExpectation) Then(sp1 *api.Secret, err error) *LogicalMock {
	e.results = &LogicalMockListResults{sp1, err}
	return e.mock
}

// List implements Logical
func (mmList *LogicalMock) List(path string) (sp1 *api.Secret, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(path)
	}

	mm_params := &LogicalMockListParams{path}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_got := LogicalMockListParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("LogicalMock.List got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the LogicalMock.List")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(path)
	}
	mmList.t.Fatalf("Unexpected call to LogicalMock.List. %v", path)
	return
}

// ListAfterCounter returns a count of finished LogicalMock.List invocations
func (mmList *LogicalMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of LogicalMock.List invocations
func (mmList *LogicalMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to LogicalMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mLogicalMockList) Calls() []*LogicalMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*LogicalMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *LogicalMock) MinimockListDone() bool {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	return true
}

// MinimockListInspect logs each unmet expectation
func (m *LogicalMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogicalMock.List with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogicalMock.List")
		} else {
			m.t.Errorf("Expected call to LogicalMock.List with params: %#v", *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		m.t.Error("Expected call to LogicalMock.List")
	}
}

type mLogicalMockRead struct {
	mock               *LogicalMock
	defaultExpectation *LogicalMockReadExpectation
	expectations       []*LogicalMockReadExpectation

	callArgs []*LogicalMockReadParams
	mutex    sync.RWMutex
}

// LogicalMockReadExpectation specifies expectation struct of the Logical.Read
type LogicalMockReadExpectation struct {
	mock    *LogicalMock
	params  *LogicalMockReadParams
	results *LogicalMockReadResults
	Counter uint64
}

// LogicalMockReadParams contains parameters of the Logical.Read
type LogicalMockReadParams struct {
	path string
}

// LogicalMockReadResults contains results of the Logical.Read
type LogicalMockReadResults struct {
	sp1 *api.Secret
	err error
}

// Expect sets up expected params for Logical.Read
func (mmRead *mLogicalMockRead) Expect(path string) *mLogicalMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("LogicalMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &LogicalMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &LogicalMockReadParams{path}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the Logical.Read
func (mmRead *mLogicalMockRead) Inspect(f func(path string)) *mLogicalMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for LogicalMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by Logical.Read
func (mmRead *mLogicalMockRead) Return(sp1 *api.Secret, err error) *LogicalMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("LogicalMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &LogicalMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &LogicalMockReadResults{sp1, err}
	return mmRead.mock
}

//Set uses given function f to mock the Logical.Read method
func (mmRead *mLogicalMockRead) Set(f func(path string) (sp1 *api.Secret, err error)) *LogicalMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the Logical.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the Logical.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the Logical.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mLogicalMockRead) When(path string) *LogicalMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("LogicalMock.Read mock is already set by Set")
	}

	expectation := &LogicalMockReadExpectation{
		mock:   mmRead.mock,
		params: &LogicalMockReadParams{path},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up Logical.Read return parameters for the expectation previously defined by the When method
func (e *LogicalMockReadExpectation) Then(sp1 *api.Secret, err error) *LogicalMock {
	e.results = &LogicalMockReadResults{sp1, err}
	return e.mock
}

// Read implements Logical
func (mmRead *LogicalMock) Read(path string) (sp1 *api.Secret, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(path)
	}

	mm_params := &LogicalMockReadParams{path}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, mm_params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		mm_want := mmRead.ReadMock.defaultExpectation.params
		mm_got := LogicalMockReadParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRead.t.Errorf("LogicalMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRead.ReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRead.t.Fatal("No results are set for the LogicalMock.Read")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(path)
	}
	mmRead.t.Fatalf("Unexpected call to LogicalMock.Read. %v", path)
	return
}

// ReadAfterCounter returns a count of finished LogicalMock.Read invocations
func (mmRead *LogicalMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of LogicalMock.Read invocations
func (mmRead *LogicalMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to LogicalMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mLogicalMockRead) Calls() []*LogicalMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*LogicalMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *LogicalMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *LogicalMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogicalMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogicalMock.Read")
		} else {
			m.t.Errorf("Expected call to LogicalMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to LogicalMock.Read")
	}
}

type mLogicalMockReadWithData struct {
	mock               *LogicalMock
	defaultExpectation *LogicalMockReadWithDataExpectation
	expectations       []*LogicalMockReadWithDataExpectation

	callArgs []*LogicalMockReadWithDataParams
	mutex    sync.RWMutex
}

// LogicalMockReadWithDataExpectation specifies expectation struct of the Logical.ReadWithData
type LogicalMockReadWithDataExpectation struct {
	mock    *LogicalMock
	params  *LogicalMockReadWithDataParams
	results *LogicalMockReadWithDataResults
	Counter uint64
}

// LogicalMockReadWithDataParams contains parameters of the Logical.ReadWithData
type LogicalMockReadWithDataParams struct {
	path string
	data map[string][]string
}

// LogicalMockReadWithDataResults contains results of the Logical.ReadWithData
type LogicalMockReadWithDataResults struct {
	sp1 *api.Secret
	err error
}

// Expect sets up expected params for Logical.ReadWithData
func (mmReadWithData *mLogicalMockReadWithData) Expect(path string, data map[string][]string) *mLogicalMockReadWithData {
	if mmReadWithData.mock.funcReadWithData != nil {
		mmReadWithData.mock.t.Fatalf("LogicalMock.ReadWithData mock is already set by Set")
	}

	if mmReadWithData.defaultExpectation == nil {
		mmReadWithData.defaultExpectation = &LogicalMockReadWithDataExpectation{}
	}

	mmReadWithData.defaultExpectation.params = &LogicalMockReadWithDataParams{path, data}
	for _, e := range mmReadWithData.expectations {
		if minimock.Equal(e.params, mmReadWithData.defaultExpectation.params) {
			mmReadWithData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadWithData.defaultExpectation.params)
		}
	}

	return mmReadWithData
}

// Inspect accepts an inspector function that has same arguments as the Logical.ReadWithData
func (mmReadWithData *mLogicalMockReadWithData) Inspect(f func(path string, data map[string][]string)) *mLogicalMockReadWithData {
	if mmReadWithData.mock.inspectFuncReadWithData != nil {
		mmReadWithData.mock.t.Fatalf("Inspect function is already set for LogicalMock.ReadWithData")
	}

	mmReadWithData.mock.inspectFuncReadWithData = f

	return mmReadWithData
}

// Return sets up results that will be returned by Logical.ReadWithData
func (mmReadWithData *mLogicalMockReadWithData) Return(sp1 *api.Secret, err error) *LogicalMock {
	if mmReadWithData.mock.funcReadWithData != nil {
		mmReadWithData.mock.t.Fatalf("LogicalMock.ReadWithData mock is already set by Set")
	}

	if mmReadWithData.defaultExpectation == nil {
		mmReadWithData.defaultExpectation = &LogicalMockReadWithDataExpectation{mock: mmReadWithData.mock}
	}
	mmReadWithData.defaultExpectation.results = &LogicalMockReadWithDataResults{sp1, err}
	return mmReadWithData.mock
}

//Set uses given function f to mock the Logical.ReadWithData method
func (mmReadWithData *mLogicalMockReadWithData) Set(f func(path string, data map[string][]string) (sp1 *api.Secret, err error)) *LogicalMock {
	if mmReadWithData.defaultExpectation != nil {
		mmReadWithData.mock.t.Fatalf("Default expectation is already set for the Logical.ReadWithData method")
	}

	if len(mmReadWithData.expectations) > 0 {
		mmReadWithData.mock.t.Fatalf("Some expectations are already set for the Logical.ReadWithData method")
	}

	mmReadWithData.mock.funcReadWithData = f
	return mmReadWithData.mock
}

// When sets expectation for the Logical.ReadWithData which will trigger the result defined by the following
// Then helper
func (mmReadWithData *mLogicalMockReadWithData) When(path string, data map[string][]string) *LogicalMockReadWithDataExpectation {
	if mmReadWithData.mock.funcReadWithData != nil {
		mmReadWithData.mock.t.Fatalf("LogicalMock.ReadWithData mock is already set by Set")
	}

	expectation := &LogicalMockReadWithDataExpectation{
		mock:   mmReadWithData.mock,
		params: &LogicalMockReadWithDataParams{path, data},
	}
	mmReadWithData.expectations = append(mmReadWithData.expectations, expectation)
	return expectation
}

// Then sets up Logical.ReadWithData return parameters for the expectation previously defined by the When method
func (e *LogicalMockReadWithDataExpectation) Then(sp1 *api.Secret, err error) *LogicalMock {
	e.results = &LogicalMockReadWithDataResults{sp1, err}
	return e.mock
}

// ReadWithData implements Logical
func (mmReadWithData *LogicalMock) ReadWithData(path string, data map[string][]string) (sp1 *api.Secret, err error) {
	mm_atomic.AddUint64(&mmReadWithData.beforeReadWithDataCounter, 1)
	defer mm_atomic.AddUint64(&mmReadWithData.afterReadWithDataCounter, 1)

	if mmReadWithData.inspectFuncReadWithData != nil {
		mmReadWithData.inspectFuncReadWithData(path, data)
	}

	mm_params := &LogicalMockReadWithDataParams{path, data}

	// Record call args
	mmReadWithData.ReadWithDataMock.mutex.Lock()
	mmReadWithData.ReadWithDataMock.callArgs = append(mmReadWithData.ReadWithDataMock.callArgs, mm_params)
	mmReadWithData.ReadWithDataMock.mutex.Unlock()

	for _, e := range mmReadWithData.ReadWithDataMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmReadWithData.ReadWithDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadWithData.ReadWithDataMock.defaultExpectation.Counter, 1)
		mm_want := mmReadWithData.ReadWithDataMock.defaultExpectation.params
		mm_got := LogicalMockReadWithDataParams{path, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadWithData.t.Errorf("LogicalMock.ReadWithData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadWithData.ReadWithDataMock.defaultExpectation.results
		if mm_results == nil {
			mmReadWithData.t.Fatal("No results are set for the LogicalMock.ReadWithData")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmReadWithData.funcReadWithData != nil {
		return mmReadWithData.funcReadWithData(path, data)
	}
	mmReadWithData.t.Fatalf("Unexpected call to LogicalMock.ReadWithData. %v %v", path, data)
	return
}

// ReadWithDataAfterCounter returns a count of finished LogicalMock.ReadWithData invocations
func (mmReadWithData *LogicalMock) ReadWithDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadWithData.afterReadWithDataCounter)
}

// ReadWithDataBeforeCounter returns a count of LogicalMock.ReadWithData invocations
func (mmReadWithData *LogicalMock) ReadWithDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadWithData.beforeReadWithDataCounter)
}

// Calls returns a list of arguments used in each call to LogicalMock.ReadWithData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadWithData *mLogicalMockReadWithData) Calls() []*LogicalMockReadWithDataParams {
	mmReadWithData.mutex.RLock()

	argCopy := make([]*LogicalMockReadWithDataParams, len(mmReadWithData.callArgs))
	copy(argCopy, mmReadWithData.callArgs)

	mmReadWithData.mutex.RUnlock()

	return argCopy
}

// MinimockReadWithDataDone returns true if the count of the ReadWithData invocations corresponds
// the number of defined expectations
func (m *LogicalMock) MinimockReadWithDataDone() bool {
	for _, e := range m.ReadWithDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadWithDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadWithDataCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadWithData != nil && mm_atomic.LoadUint64(&m.afterReadWithDataCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadWithDataInspect logs each unmet expectation
func (m *LogicalMock) MinimockReadWithDataInspect() {
	for _, e := range m.ReadWithDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogicalMock.ReadWithData with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadWithDataMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadWithDataCounter) < 1 {
		if m.ReadWithDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogicalMock.ReadWithData")
		} else {
			m.t.Errorf("Expected call to LogicalMock.ReadWithData with params: %#v", *m.ReadWithDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadWithData != nil && mm_atomic.LoadUint64(&m.afterReadWithDataCounter) < 1 {
		m.t.Error("Expected call to LogicalMock.ReadWithData")
	}
}

type mLogicalMockUnwrap struct {
	mock               *LogicalMock
	defaultExpectation *LogicalMockUnwrapExpectation
	expectations       []*LogicalMockUnwrapExpectation

	callArgs []*LogicalMockUnwrapParams
	mutex    sync.RWMutex
}

// LogicalMockUnwrapExpectation specifies expectation struct of the Logical.Unwrap
type LogicalMockUnwrapExpectation struct {
	mock    *LogicalMock
	params  *LogicalMockUnwrapParams
	results *LogicalMockUnwrapResults
	Counter uint64
}

// LogicalMockUnwrapParams contains parameters of the Logical.Unwrap
type LogicalMockUnwrapParams struct {
	wrappingToken string
}

// LogicalMockUnwrapResults contains results of the Logical.Unwrap
type LogicalMockUnwrapResults struct {
	sp1 *api.Secret
	err error
}

// Expect sets up expected params for Logical.Unwrap
func (mmUnwrap *mLogicalMockUnwrap) Expect(wrappingToken string) *mLogicalMockUnwrap {
	if mmUnwrap.mock.funcUnwrap != nil {
		mmUnwrap.mock.t.Fatalf("LogicalMock.Unwrap mock is already set by Set")
	}

	if mmUnwrap.defaultExpectation == nil {
		mmUnwrap.defaultExpectation = &LogicalMockUnwrapExpectation{}
	}

	mmUnwrap.defaultExpectation.params = &LogicalMockUnwrapParams{wrappingToken}
	for _, e := range mmUnwrap.expectations {
		if minimock.Equal(e.params, mmUnwrap.defaultExpectation.params) {
			mmUnwrap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnwrap.defaultExpectation.params)
		}
	}

	return mmUnwrap
}

// Inspect accepts an inspector function that has same arguments as the Logical.Unwrap
func (mmUnwrap *mLogicalMockUnwrap) Inspect(f func(wrappingToken string)) *mLogicalMockUnwrap {
	if mmUnwrap.mock.inspectFuncUnwrap != nil {
		mmUnwrap.mock.t.Fatalf("Inspect function is already set for LogicalMock.Unwrap")
	}

	mmUnwrap.mock.inspectFuncUnwrap = f

	return mmUnwrap
}

// Return sets up results that will be returned by Logical.Unwrap
func (mmUnwrap *mLogicalMockUnwrap) Return(sp1 *api.Secret, err error) *LogicalMock {
	if mmUnwrap.mock.funcUnwrap != nil {
		mmUnwrap.mock.t.Fatalf("LogicalMock.Unwrap mock is already set by Set")
	}

	if mmUnwrap.defaultExpectation == nil {
		mmUnwrap.defaultExpectation = &LogicalMockUnwrapExpectation{mock: mmUnwrap.mock}
	}
	mmUnwrap.defaultExpectation.results = &LogicalMockUnwrapResults{sp1, err}
	return mmUnwrap.mock
}

//Set uses given function f to mock the Logical.Unwrap method
func (mmUnwrap *mLogicalMockUnwrap) Set(f func(wrappingToken string) (sp1 *api.Secret, err error)) *LogicalMock {
	if mmUnwrap.defaultExpectation != nil {
		mmUnwrap.mock.t.Fatalf("Default expectation is already set for the Logical.Unwrap method")
	}

	if len(mmUnwrap.expectations) > 0 {
		mmUnwrap.mock.t.Fatalf("Some expectations are already set for the Logical.Unwrap method")
	}

	mmUnwrap.mock.funcUnwrap = f
	return mmUnwrap.mock
}

// When sets expectation for the Logical.Unwrap which will trigger the result defined by the following
// Then helper
func (mmUnwrap *mLogicalMockUnwrap) When(wrappingToken string) *LogicalMockUnwrapExpectation {
	if mmUnwrap.mock.funcUnwrap != nil {
		mmUnwrap.mock.t.Fatalf("LogicalMock.Unwrap mock is already set by Set")
	}

	expectation := &LogicalMockUnwrapExpectation{
		mock:   mmUnwrap.mock,
		params: &LogicalMockUnwrapParams{wrappingToken},
	}
	mmUnwrap.expectations = append(mmUnwrap.expectations, expectation)
	return expectation
}

// Then sets up Logical.Unwrap return parameters for the expectation previously defined by the When method
func (e *LogicalMockUnwrapExpectation) Then(sp1 *api.Secret, err error) *LogicalMock {
	e.results = &LogicalMockUnwrapResults{sp1, err}
	return e.mock
}

// Unwrap implements Logical
func (mmUnwrap *LogicalMock) Unwrap(wrappingToken string) (sp1 *api.Secret, err error) {
	mm_atomic.AddUint64(&mmUnwrap.beforeUnwrapCounter, 1)
	defer mm_atomic.AddUint64(&mmUnwrap.afterUnwrapCounter, 1)

	if mmUnwrap.inspectFuncUnwrap != nil {
		mmUnwrap.inspectFuncUnwrap(wrappingToken)
	}

	mm_params := &LogicalMockUnwrapParams{wrappingToken}

	// Record call args
	mmUnwrap.UnwrapMock.mutex.Lock()
	mmUnwrap.UnwrapMock.callArgs = append(mmUnwrap.UnwrapMock.callArgs, mm_params)
	mmUnwrap.UnwrapMock.mutex.Unlock()

	for _, e := range mmUnwrap.UnwrapMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmUnwrap.UnwrapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnwrap.UnwrapMock.defaultExpectation.Counter, 1)
		mm_want := mmUnwrap.UnwrapMock.defaultExpectation.params
		mm_got := LogicalMockUnwrapParams{wrappingToken}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnwrap.t.Errorf("LogicalMock.Unwrap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnwrap.UnwrapMock.defaultExpectation.results
		if mm_results == nil {
			mmUnwrap.t.Fatal("No results are set for the LogicalMock.Unwrap")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmUnwrap.funcUnwrap != nil {
		return mmUnwrap.funcUnwrap(wrappingToken)
	}
	mmUnwrap.t.Fatalf("Unexpected call to LogicalMock.Unwrap. %v", wrappingToken)
	return
}

// UnwrapAfterCounter returns a count of finished LogicalMock.Unwrap invocations
func (mmUnwrap *LogicalMock) UnwrapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnwrap.afterUnwrapCounter)
}

// UnwrapBeforeCounter returns a count of LogicalMock.Unwrap invocations
func (mmUnwrap *LogicalMock) UnwrapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnwrap.beforeUnwrapCounter)
}

// Calls returns a list of arguments used in each call to LogicalMock.Unwrap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnwrap *mLogicalMockUnwrap) Calls() []*LogicalMockUnwrapParams {
	mmUnwrap.mutex.RLock()

	argCopy := make([]*LogicalMockUnwrapParams, len(mmUnwrap.callArgs))
	copy(argCopy, mmUnwrap.callArgs)

	mmUnwrap.mutex.RUnlock()

	return argCopy
}

// MinimockUnwrapDone returns true if the count of the Unwrap invocations corresponds
// the number of defined expectations
func (m *LogicalMock) MinimockUnwrapDone() bool {
	for _, e := range m.UnwrapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnwrapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnwrapCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnwrap != nil && mm_atomic.LoadUint64(&m.afterUnwrapCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnwrapInspect logs each unmet expectation
func (m *LogicalMock) MinimockUnwrapInspect() {
	for _, e := range m.UnwrapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogicalMock.Unwrap with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnwrapMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnwrapCounter) < 1 {
		if m.UnwrapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogicalMock.Unwrap")
		} else {
			m.t.Errorf("Expected call to LogicalMock.Unwrap with params: %#v", *m.UnwrapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnwrap != nil && mm_atomic.LoadUint64(&m.afterUnwrapCounter) < 1 {
		m.t.Error("Expected call to LogicalMock.Unwrap")
	}
}

type mLogicalMockWrite struct {
	mock               *LogicalMock
	defaultExpectation *LogicalMockWriteExpectation
	expectations       []*LogicalMockWriteExpectation

	callArgs []*LogicalMockWriteParams
	mutex    sync.RWMutex
}

// LogicalMockWriteExpectation specifies expectation struct of the Logical.Write
type LogicalMockWriteExpectation struct {
	mock    *LogicalMock
	params  *LogicalMockWriteParams
	results *LogicalMockWriteResults
	Counter uint64
}

// LogicalMockWriteParams contains parameters of the Logical.Write
type LogicalMockWriteParams struct {
	path string
	data map[string]interface{}
}

// LogicalMockWriteResults contains results of the Logical.Write
type LogicalMockWriteResults struct {
	sp1 *api.Secret
	err error
}

// Expect sets up expected params for Logical.Write
func (mmWrite *mLogicalMockWrite) Expect(path string, data map[string]interface{}) *mLogicalMockWrite {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("LogicalMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &LogicalMockWriteExpectation{}
	}

	mmWrite.defaultExpectation.params = &LogicalMockWriteParams{path, data}
	for _, e := range mmWrite.expectations {
		if minimock.Equal(e.params, mmWrite.defaultExpectation.params) {
			mmWrite.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWrite.defaultExpectation.params)
		}
	}

	return mmWrite
}

// Inspect accepts an inspector function that has same arguments as the Logical.Write
func (mmWrite *mLogicalMockWrite) Inspect(f func(path string, data map[string]interface{})) *mLogicalMockWrite {
	if mmWrite.mock.inspectFuncWrite != nil {
		mmWrite.mock.t.Fatalf("Inspect function is already set for LogicalMock.Write")
	}

	mmWrite.mock.inspectFuncWrite = f

	return mmWrite
}

// Return sets up results that will be returned by Logical.Write
func (mmWrite *mLogicalMockWrite) Return(sp1 *api.Secret, err error) *LogicalMock {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("LogicalMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &LogicalMockWriteExpectation{mock: mmWrite.mock}
	}
	mmWrite.defaultExpectation.results = &LogicalMockWriteResults{sp1, err}
	return mmWrite.mock
}

//Set uses given function f to mock the Logical.Write method
func (mmWrite *mLogicalMockWrite) Set(f func(path string, data map[string]interface{}) (sp1 *api.Secret, err error)) *LogicalMock {
	if mmWrite.defaultExpectation != nil {
		mmWrite.mock.t.Fatalf("Default expectation is already set for the Logical.Write method")
	}

	if len(mmWrite.expectations) > 0 {
		mmWrite.mock.t.Fatalf("Some expectations are already set for the Logical.Write method")
	}

	mmWrite.mock.funcWrite = f
	return mmWrite.mock
}

// When sets expectation for the Logical.Write which will trigger the result defined by the following
// Then helper
func (mmWrite *mLogicalMockWrite) When(path string, data map[string]interface{}) *LogicalMockWriteExpectation {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("LogicalMock.Write mock is already set by Set")
	}

	expectation := &LogicalMockWriteExpectation{
		mock:   mmWrite.mock,
		params: &LogicalMockWriteParams{path, data},
	}
	mmWrite.expectations = append(mmWrite.expectations, expectation)
	return expectation
}

// Then sets up Logical.Write return parameters for the expectation previously defined by the When method
func (e *LogicalMockWriteExpectation) Then(sp1 *api.Secret, err error) *LogicalMock {
	e.results = &LogicalMockWriteResults{sp1, err}
	return e.mock
}

// Write implements Logical
func (mmWrite *LogicalMock) Write(path string, data map[string]interface{}) (sp1 *api.Secret, err error) {
	mm_atomic.AddUint64(&mmWrite.beforeWriteCounter, 1)
	defer mm_atomic.AddUint64(&mmWrite.afterWriteCounter, 1)

	if mmWrite.inspectFuncWrite != nil {
		mmWrite.inspectFuncWrite(path, data)
	}

	mm_params := &LogicalMockWriteParams{path, data}

	// Record call args
	mmWrite.WriteMock.mutex.Lock()
	mmWrite.WriteMock.callArgs = append(mmWrite.WriteMock.callArgs, mm_params)
	mmWrite.WriteMock.mutex.Unlock()

	for _, e := range mmWrite.WriteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmWrite.WriteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWrite.WriteMock.defaultExpectation.Counter, 1)
		mm_want := mmWrite.WriteMock.defaultExpectation.params
		mm_got := LogicalMockWriteParams{path, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWrite.t.Errorf("LogicalMock.Write got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWrite.WriteMock.defaultExpectation.results
		if mm_results == nil {
			mmWrite.t.Fatal("No results are set for the LogicalMock.Write")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmWrite.funcWrite != nil {
		return mmWrite.funcWrite(path, data)
	}
	mmWrite.t.Fatalf("Unexpected call to LogicalMock.Write. %v %v", path, data)
	return
}

// WriteAfterCounter returns a count of finished LogicalMock.Write invocations
func (mmWrite *LogicalMock) WriteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.afterWriteCounter)
}

// WriteBeforeCounter returns a count of LogicalMock.Write invocations
func (mmWrite *LogicalMock) WriteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.beforeWriteCounter)
}

// Calls returns a list of arguments used in each call to LogicalMock.Write.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWrite *mLogicalMockWrite) Calls() []*LogicalMockWriteParams {
	mmWrite.mutex.RLock()

	argCopy := make([]*LogicalMockWriteParams, len(mmWrite.callArgs))
	copy(argCopy, mmWrite.callArgs)

	mmWrite.mutex.RUnlock()

	return argCopy
}

// MinimockWriteDone returns true if the count of the Write invocations corresponds
// the number of defined expectations
func (m *LogicalMock) MinimockWriteDone() bool {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteInspect logs each unmet expectation
func (m *LogicalMock) MinimockWriteInspect() {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogicalMock.Write with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		if m.WriteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogicalMock.Write")
		} else {
			m.t.Errorf("Expected call to LogicalMock.Write with params: %#v", *m.WriteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		m.t.Error("Expected call to LogicalMock.Write")
	}
}

type mLogicalMockWriteBytes struct {
	mock               *LogicalMock
	defaultExpectation *LogicalMockWriteBytesExpectation
	expectations       []*LogicalMockWriteBytesExpectation

	callArgs []*LogicalMockWriteBytesParams
	mutex    sync.RWMutex
}

// LogicalMockWriteBytesExpectation specifies expectation struct of the Logical.WriteBytes
type LogicalMockWriteBytesExpectation struct {
	mock    *LogicalMock
	params  *LogicalMockWriteBytesParams
	results *LogicalMockWriteBytesResults
	Counter uint64
}

// LogicalMockWriteBytesParams contains parameters of the Logical.WriteBytes
type LogicalMockWriteBytesParams struct {
	path string
	data []byte
}

// LogicalMockWriteBytesResults contains results of the Logical.WriteBytes
type LogicalMockWriteBytesResults struct {
	sp1 *api.Secret
	err error
}

// Expect sets up expected params for Logical.WriteBytes
func (mmWriteBytes *mLogicalMockWriteBytes) Expect(path string, data []byte) *mLogicalMockWriteBytes {
	if mmWriteBytes.mock.funcWriteBytes != nil {
		mmWriteBytes.mock.t.Fatalf("LogicalMock.WriteBytes mock is already set by Set")
	}

	if mmWriteBytes.defaultExpectation == nil {
		mmWriteBytes.defaultExpectation = &LogicalMockWriteBytesExpectation{}
	}

	mmWriteBytes.defaultExpectation.params = &LogicalMockWriteBytesParams{path, data}
	for _, e := range mmWriteBytes.expectations {
		if minimock.Equal(e.params, mmWriteBytes.defaultExpectation.params) {
			mmWriteBytes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteBytes.defaultExpectation.params)
		}
	}

	return mmWriteBytes
}

// Inspect accepts an inspector function that has same arguments as the Logical.WriteBytes
func (mmWriteBytes *mLogicalMockWriteBytes) Inspect(f func(path string, data []byte)) *mLogicalMockWriteBytes {
	if mmWriteBytes.mock.inspectFuncWriteBytes != nil {
		mmWriteBytes.mock.t.Fatalf("Inspect function is already set for LogicalMock.WriteBytes")
	}

	mmWriteBytes.mock.inspectFuncWriteBytes = f

	return mmWriteBytes
}

// Return sets up results that will be returned by Logical.WriteBytes
func (mmWriteBytes *mLogicalMockWriteBytes) Return(sp1 *api.Secret, err error) *LogicalMock {
	if mmWriteBytes.mock.funcWriteBytes != nil {
		mmWriteBytes.mock.t.Fatalf("LogicalMock.WriteBytes mock is already set by Set")
	}

	if mmWriteBytes.defaultExpectation == nil {
		mmWriteBytes.defaultExpectation = &LogicalMockWriteBytesExpectation{mock: mmWriteBytes.mock}
	}
	mmWriteBytes.defaultExpectation.results = &LogicalMockWriteBytesResults{sp1, err}
	return mmWriteBytes.mock
}

//Set uses given function f to mock the Logical.WriteBytes method
func (mmWriteBytes *mLogicalMockWriteBytes) Set(f func(path string, data []byte) (sp1 *api.Secret, err error)) *LogicalMock {
	if mmWriteBytes.defaultExpectation != nil {
		mmWriteBytes.mock.t.Fatalf("Default expectation is already set for the Logical.WriteBytes method")
	}

	if len(mmWriteBytes.expectations) > 0 {
		mmWriteBytes.mock.t.Fatalf("Some expectations are already set for the Logical.WriteBytes method")
	}

	mmWriteBytes.mock.funcWriteBytes = f
	return mmWriteBytes.mock
}

// When sets expectation for the Logical.WriteBytes which will trigger the result defined by the following
// Then helper
func (mmWriteBytes *mLogicalMockWriteBytes) When(path string, data []byte) *LogicalMockWriteBytesExpectation {
	if mmWriteBytes.mock.funcWriteBytes != nil {
		mmWriteBytes.mock.t.Fatalf("LogicalMock.WriteBytes mock is already set by Set")
	}

	expectation := &LogicalMockWriteBytesExpectation{
		mock:   mmWriteBytes.mock,
		params: &LogicalMockWriteBytesParams{path, data},
	}
	mmWriteBytes.expectations = append(mmWriteBytes.expectations, expectation)
	return expectation
}

// Then sets up Logical.WriteBytes return parameters for the expectation previously defined by the When method
func (e *LogicalMockWriteBytesExpectation) Then(sp1 *api.Secret, err error) *LogicalMock {
	e.results = &LogicalMockWriteBytesResults{sp1, err}
	return e.mock
}

// WriteBytes implements Logical
func (mmWriteBytes *LogicalMock) WriteBytes(path string, data []byte) (sp1 *api.Secret, err error) {
	mm_atomic.AddUint64(&mmWriteBytes.beforeWriteBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteBytes.afterWriteBytesCounter, 1)

	if mmWriteBytes.inspectFuncWriteBytes != nil {
		mmWriteBytes.inspectFuncWriteBytes(path, data)
	}

	mm_params := &LogicalMockWriteBytesParams{path, data}

	// Record call args
	mmWriteBytes.WriteBytesMock.mutex.Lock()
	mmWriteBytes.WriteBytesMock.callArgs = append(mmWriteBytes.WriteBytesMock.callArgs, mm_params)
	mmWriteBytes.WriteBytesMock.mutex.Unlock()

	for _, e := range mmWriteBytes.WriteBytesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmWriteBytes.WriteBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteBytes.WriteBytesMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteBytes.WriteBytesMock.defaultExpectation.params
		mm_got := LogicalMockWriteBytesParams{path, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteBytes.t.Errorf("LogicalMock.WriteBytes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteBytes.WriteBytesMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteBytes.t.Fatal("No results are set for the LogicalMock.WriteBytes")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmWriteBytes.funcWriteBytes != nil {
		return mmWriteBytes.funcWriteBytes(path, data)
	}
	mmWriteBytes.t.Fatalf("Unexpected call to LogicalMock.WriteBytes. %v %v", path, data)
	return
}

// WriteBytesAfterCounter returns a count of finished LogicalMock.WriteBytes invocations
func (mmWriteBytes *LogicalMock) WriteBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteBytes.afterWriteBytesCounter)
}

// WriteBytesBeforeCounter returns a count of LogicalMock.WriteBytes invocations
func (mmWriteBytes *LogicalMock) WriteBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteBytes.beforeWriteBytesCounter)
}

// Calls returns a list of arguments used in each call to LogicalMock.WriteBytes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteBytes *mLogicalMockWriteBytes) Calls() []*LogicalMockWriteBytesParams {
	mmWriteBytes.mutex.RLock()

	argCopy := make([]*LogicalMockWriteBytesParams, len(mmWriteBytes.callArgs))
	copy(argCopy, mmWriteBytes.callArgs)

	mmWriteBytes.mutex.RUnlock()

	return argCopy
}

// MinimockWriteBytesDone returns true if the count of the WriteBytes invocations corresponds
// the number of defined expectations
func (m *LogicalMock) MinimockWriteBytesDone() bool {
	for _, e := range m.WriteBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteBytesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteBytes != nil && mm_atomic.LoadUint64(&m.afterWriteBytesCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteBytesInspect logs each unmet expectation
func (m *LogicalMock) MinimockWriteBytesInspect() {
	for _, e := range m.WriteBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LogicalMock.WriteBytes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteBytesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteBytesCounter) < 1 {
		if m.WriteBytesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LogicalMock.WriteBytes")
		} else {
			m.t.Errorf("Expected call to LogicalMock.WriteBytes with params: %#v", *m.WriteBytesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteBytes != nil && mm_atomic.LoadUint64(&m.afterWriteBytesCounter) < 1 {
		m.t.Error("Expected call to LogicalMock.WriteBytes")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LogicalMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeleteInspect()

		m.MinimockDeleteWithDataInspect()

		m.MinimockListInspect()

		m.MinimockReadInspect()

		m.MinimockReadWithDataInspect()

		m.MinimockUnwrapInspect()

		m.MinimockWriteInspect()

		m.MinimockWriteBytesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LogicalMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LogicalMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteWithDataDone() &&
		m.MinimockListDone() &&
		m.MinimockReadDone() &&
		m.MinimockReadWithDataDone() &&
		m.MinimockUnwrapDone() &&
		m.MinimockWriteDone() &&
		m.MinimockWriteBytesDone()
}
